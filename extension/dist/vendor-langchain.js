import{s as Cn,v as z,c as Pn,R as gt,g as xn,C as In,a as Rn,b as An,P as ie,p as rt,d as Y,e as jn,f as Le,_ as Nn,$ as Mn,h as Ln,t as Rt,z as $n,i as je,j as bt,k as At,o as Fn,l as Dn,m as Bn,T as Hn,n as Un}from"./vendor.js";import{F as Ie,G as jt}from"./vendor-google.js";var zn={};const Gn=()=>typeof window<"u"&&typeof window.document<"u",Wn=()=>typeof globalThis=="object"&&globalThis.constructor&&globalThis.constructor.name==="DedicatedWorkerGlobalScope",Jn=()=>typeof window<"u"&&window.name==="nodejs"||typeof navigator<"u"&&navigator.userAgent.includes("jsdom"),yt=()=>typeof Deno<"u",Kn=()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"&&!yt(),Vn=()=>{let r;return Gn()?r="browser":Kn()?r="node":Wn()?r="webworker":Jn()?r="jsdom":yt()?r="deno":r="other",r};let Ve;function qn(){return Ve===void 0&&(Ve={library:"langchain-js",runtime:Vn()}),Ve}function X(r){try{return typeof process<"u"?zn?.[r]:yt()?Deno?.env.get(r):void 0}catch{return}}function Nt(r,e=on){r=r.trim();const t=r.indexOf("```");if(t===-1)return e(r);let n=r.substring(t+3);n.startsWith(`json
`)?n=n.substring(5):n.startsWith("json")?n=n.substring(4):n.startsWith(`
`)&&(n=n.substring(1));const a=n.indexOf("```");let s=n;return a!==-1&&(s=n.substring(0,a)),e(s.trim())}function on(r){if(typeof r>"u")return null;try{return JSON.parse(r)}catch{}let e="";const t=[];let n=!1,a=!1;for(let s of r){if(n)s==='"'&&!a?n=!1:s===`
`&&!a?s="\\n":s==="\\"?a=!a:a=!1;else if(s==='"')n=!0,a=!1;else if(s==="{")t.push("}");else if(s==="[")t.push("]");else if(s==="}"||s==="]")if(t&&t[t.length-1]===s)t.pop();else return null;e+=s}n&&(e+='"');for(let s=t.length-1;s>=0;s-=1)e+=t[s];try{return JSON.parse(e)}catch{return null}}function Zn(r,e){return e?.[r]||Cn(r)}function Yn(r,e,t){const n={};for(const a in r)Object.hasOwn(r,a)&&(n[e(a,t)]=r[a]);return n}function Mt(r){return Array.isArray(r)?[...r]:{...r}}function Qn(r,e){const t=Mt(r);for(const[n,a]of Object.entries(e)){const[s,...i]=n.split(".").reverse();let o=t;for(const u of i.reverse()){if(o[u]===void 0)break;o[u]=Mt(o[u]),o=o[u]}o[s]!==void 0&&(o[s]={lc:1,type:"secret",id:[a]})}return t}function un(r){const e=Object.getPrototypeOf(r);return typeof r.lc_name=="function"&&(typeof e.lc_name!="function"||r.lc_name()!==e.lc_name())?r.lc_name():r.name}class te{static lc_name(){return this.name}get lc_id(){return[...this.lc_namespace,un(this.constructor)]}get lc_secrets(){}get lc_attributes(){}get lc_aliases(){}get lc_serializable_keys(){}constructor(e,...t){Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lc_kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.lc_serializable_keys!==void 0?this.lc_kwargs=Object.fromEntries(Object.entries(e||{}).filter(([n])=>this.lc_serializable_keys?.includes(n))):this.lc_kwargs=e??{}}toJSON(){if(!this.lc_serializable)return this.toJSONNotImplemented();if(this.lc_kwargs instanceof te||typeof this.lc_kwargs!="object"||Array.isArray(this.lc_kwargs))return this.toJSONNotImplemented();const e={},t={},n=Object.keys(this.lc_kwargs).reduce((a,s)=>(a[s]=s in this?this[s]:this.lc_kwargs[s],a),{});for(let a=Object.getPrototypeOf(this);a;a=Object.getPrototypeOf(a))Object.assign(e,Reflect.get(a,"lc_aliases",this)),Object.assign(t,Reflect.get(a,"lc_secrets",this)),Object.assign(n,Reflect.get(a,"lc_attributes",this));return Object.keys(t).forEach(a=>{let s=this,i=n;const[o,...u]=a.split(".").reverse();for(const l of u.reverse()){if(!(l in s)||s[l]===void 0)return;(!(l in i)||i[l]===void 0)&&(typeof s[l]=="object"&&s[l]!=null?i[l]={}:Array.isArray(s[l])&&(i[l]=[])),s=s[l],i=i[l]}o in s&&s[o]!==void 0&&(i[o]=i[o]||s[o])}),{lc:1,type:"constructor",id:this.lc_id,kwargs:Yn(Object.keys(t).length?Qn(n,t):n,Zn,e)}}toJSONNotImplemented(){return{lc:1,type:"not_implemented",id:this.lc_id}}}function se(r){return typeof r=="object"&&r!==null&&"type"in r&&typeof r.type=="string"&&"source_type"in r&&(r.source_type==="url"||r.source_type==="base64"||r.source_type==="text"||r.source_type==="id")}function Xn(r){return se(r)&&r.source_type==="url"&&"url"in r&&typeof r.url=="string"}function er(r){return se(r)&&r.source_type==="base64"&&"data"in r&&typeof r.data=="string"}function tr(r){if(se(r)){if(r.source_type==="url")return{type:"image_url",image_url:{url:r.url}};if(r.source_type==="base64"){if(!r.mime_type)throw new Error("mime_type key is required for base64 data.");return{type:"image_url",image_url:{url:`data:${r.mime_type};base64,${r.data}`}}}}throw new Error("Unsupported source type. Only 'url' and 'base64' are supported.")}function qe({dataUrl:r,asTypedArray:e=!1}){const t=r.match(/^data:(\w+\/\w+);base64,([A-Za-z0-9+/]+=*)$/);let n;if(t){n=t[1].toLowerCase();const a=e?Uint8Array.from(atob(t[2]),s=>s.charCodeAt(0)):t[2];return{mime_type:n,data:a}}}function nr(r,e){if(r.type==="text"){if(!e.fromStandardTextBlock)throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardTextBlock\` method.`);return e.fromStandardTextBlock(r)}if(r.type==="image"){if(!e.fromStandardImageBlock)throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardImageBlock\` method.`);return e.fromStandardImageBlock(r)}if(r.type==="audio"){if(!e.fromStandardAudioBlock)throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardAudioBlock\` method.`);return e.fromStandardAudioBlock(r)}if(r.type==="file"){if(!e.fromStandardFileBlock)throw new Error(`Converter for ${e.providerName} does not implement \`fromStandardFileBlock\` method.`);return e.fromStandardFileBlock(r)}throw new Error(`Unable to convert content block type '${r.type}' to provider-specific format: not recognized.`)}function ke(r,e){return typeof r=="string"?r===""?e:typeof e=="string"?r+e:Array.isArray(e)&&e.some(t=>se(t))?[{type:"text",source_type:"text",text:r},...e]:[{type:"text",text:r},...e]:Array.isArray(e)?_t(r,e)??[...r,...e]:e===""?r:Array.isArray(r)&&r.some(t=>se(t))?[...r,{type:"file",source_type:"text",text:e}]:[...r,{type:"text",text:e}]}function rr(r,e){function t(n,a){if(typeof n!="object"||n===null||n===void 0)return n;if(a>=e)return Array.isArray(n)?"[Array]":"[Object]";if(Array.isArray(n))return n.map(i=>t(i,a+1));const s={};for(const i of Object.keys(n))s[i]=t(n[i],a+1);return s}return JSON.stringify(t(r,0),null,2)}class le extends te{get lc_aliases(){return{additional_kwargs:"additional_kwargs",response_metadata:"response_metadata"}}get text(){return typeof this.content=="string"?this.content:Array.isArray(this.content)?this.content.map(e=>typeof e=="string"?e:e.type==="text"?e.text:"").join(""):""}getType(){return this._getType()}constructor(e,t){typeof e=="string"&&(e={content:e,additional_kwargs:t,response_metadata:{}}),e.additional_kwargs||(e.additional_kwargs={}),e.response_metadata||(e.response_metadata={}),super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","messages"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"content",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"additional_kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"response_metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=e.name,this.content=e.content,this.additional_kwargs=e.additional_kwargs,this.response_metadata=e.response_metadata,this.id=e.id}toDict(){return{type:this._getType(),data:this.toJSON().kwargs}}static lc_name(){return"BaseMessage"}get _printableFields(){return{id:this.id,content:this.content,name:this.name,additional_kwargs:this.additional_kwargs,response_metadata:this.response_metadata}}_updateId(e){this.id=e,this.lc_kwargs.id=e}get[Symbol.toStringTag](){return this.constructor.lc_name()}[Symbol.for("nodejs.util.inspect.custom")](e){if(e===null)return this;const t=rr(this._printableFields,Math.max(4,e));return`${this.constructor.lc_name()} ${t}`}}function L(r,e){const t={...r};for(const[n,a]of Object.entries(e))if(t[n]==null)t[n]=a;else{if(a==null)continue;if(typeof t[n]!=typeof a||Array.isArray(t[n])!==Array.isArray(a))throw new Error(`field[${n}] already exists in the message chunk, but with a different type.`);if(typeof t[n]=="string"){if(n==="type")continue;t[n]+=a}else if(typeof t[n]=="object"&&!Array.isArray(t[n]))t[n]=L(t[n],a);else if(Array.isArray(t[n]))t[n]=_t(t[n],a);else{if(t[n]===a)continue;console.warn(`field[${n}] already exists in this message chunk and value has unsupported type.`)}}return t}function _t(r,e){if(!(r===void 0&&e===void 0)){if(r===void 0||e===void 0)return r||e;{const t=[...r];for(const n of e)if(typeof n=="object"&&"index"in n&&typeof n.index=="number"){const a=t.findIndex(s=>s.index===n.index);a!==-1?t[a]=L(t[a],n):t.push(n)}else{if(typeof n=="object"&&"text"in n&&n.text==="")continue;t.push(n)}return t}}}class Te extends le{}function ar(r){return typeof r.role=="string"}function Ee(r){return typeof r?._getType=="function"}function ir(r){return Ee(r)&&typeof r.concat=="function"}class sr extends le{static lc_name(){return"ToolMessage"}get lc_aliases(){return{tool_call_id:"tool_call_id"}}constructor(e,t,n){typeof e=="string"&&(e={content:e,name:n,tool_call_id:t}),super(e),Object.defineProperty(this,"lc_direct_tool_output",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"status",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tool_call_id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"artifact",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.tool_call_id=e.tool_call_id,this.artifact=e.artifact,this.status=e.status,this.metadata=e.metadata}_getType(){return"tool"}static isInstance(e){return e._getType()==="tool"}get _printableFields(){return{...super._printableFields,tool_call_id:this.tool_call_id,artifact:this.artifact}}}function or(r){const e=[],t=[];for(const n of r)if(n.function){const a=n.function.name;try{const s=JSON.parse(n.function.arguments),i={name:a||"",args:s||{},id:n.id};e.push(i)}catch{t.push({name:a,args:n.function.arguments,id:n.id,error:"Malformed args."})}}else continue;return[e,t]}function ur(r){return r._getType()==="tool"}class at extends le{get lc_aliases(){return{...super.lc_aliases,tool_calls:"tool_calls",invalid_tool_calls:"invalid_tool_calls"}}constructor(e,t){let n;if(typeof e=="string")n={content:e,tool_calls:[],invalid_tool_calls:[],additional_kwargs:t??{}};else{n=e;const a=n.additional_kwargs?.tool_calls,s=n.tool_calls;a!=null&&a.length>0&&(s===void 0||s.length===0)&&console.warn(["New LangChain packages are available that more efficiently handle",`tool calling.

Please upgrade your packages to versions that set`,"message tool calls. e.g., `yarn add @langchain/anthropic`,","yarn add @langchain/openai`, etc."].join(" "));try{if(a!=null&&s===void 0){const[i,o]=or(a);n.tool_calls=i??[],n.invalid_tool_calls=o??[]}else n.tool_calls=n.tool_calls??[],n.invalid_tool_calls=n.invalid_tool_calls??[]}catch{n.tool_calls=[],n.invalid_tool_calls=[]}}super(n),Object.defineProperty(this,"tool_calls",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"invalid_tool_calls",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"usage_metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),typeof n!="string"&&(this.tool_calls=n.tool_calls??this.tool_calls,this.invalid_tool_calls=n.invalid_tool_calls??this.invalid_tool_calls),this.usage_metadata=n.usage_metadata}static lc_name(){return"AIMessage"}_getType(){return"ai"}get _printableFields(){return{...super._printableFields,tool_calls:this.tool_calls,invalid_tool_calls:this.invalid_tool_calls,usage_metadata:this.usage_metadata}}}function wt(r){return r._getType()==="ai"}function Lt(r){return r._getType()==="ai"}class ce extends Te{constructor(e){let t;if(typeof e=="string")t={content:e,tool_calls:[],invalid_tool_calls:[],tool_call_chunks:[]};else if(e.tool_call_chunks===void 0)t={...e,tool_calls:e.tool_calls??[],invalid_tool_calls:[],tool_call_chunks:[],usage_metadata:e.usage_metadata!==void 0?e.usage_metadata:void 0};else{const n=e.tool_call_chunks.reduce((i,o)=>{const u=o.id||`fallback-${o.index||0}`;return i[u]=i[u]??[],i[u].push(o),i},{}),a=[],s=[];for(const[i,o]of Object.entries(n)){let u={};const l=o[0]?.name??"",c=o.map(h=>h.args||"").join(""),f=c.length?c:"{}",d=o[0]?.id||i;try{if(u=on(f),u===null||typeof u!="object"||Array.isArray(u))throw new Error("Malformed tool call chunk args.");a.push({name:l,args:u,id:d,type:"tool_call"})}catch{s.push({name:l,args:f,id:d,error:"Malformed args.",type:"invalid_tool_call"})}}t={...e,tool_calls:a,invalid_tool_calls:s,usage_metadata:e.usage_metadata!==void 0?e.usage_metadata:void 0}}super(t),Object.defineProperty(this,"tool_calls",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"invalid_tool_calls",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"tool_call_chunks",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"usage_metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.tool_call_chunks=t.tool_call_chunks??this.tool_call_chunks,this.tool_calls=t.tool_calls??this.tool_calls,this.invalid_tool_calls=t.invalid_tool_calls??this.invalid_tool_calls,this.usage_metadata=t.usage_metadata}get lc_aliases(){return{...super.lc_aliases,tool_calls:"tool_calls",invalid_tool_calls:"invalid_tool_calls",tool_call_chunks:"tool_call_chunks"}}static lc_name(){return"AIMessageChunk"}_getType(){return"ai"}get _printableFields(){return{...super._printableFields,tool_calls:this.tool_calls,tool_call_chunks:this.tool_call_chunks,invalid_tool_calls:this.invalid_tool_calls,usage_metadata:this.usage_metadata}}concat(e){const t={content:ke(this.content,e.content),additional_kwargs:L(this.additional_kwargs,e.additional_kwargs),response_metadata:L(this.response_metadata,e.response_metadata),tool_call_chunks:[],id:this.id??e.id};if(this.tool_call_chunks!==void 0||e.tool_call_chunks!==void 0){const n=_t(this.tool_call_chunks,e.tool_call_chunks);n!==void 0&&n.length>0&&(t.tool_call_chunks=n)}if(this.usage_metadata!==void 0||e.usage_metadata!==void 0){const n={...(this.usage_metadata?.input_token_details?.audio!==void 0||e.usage_metadata?.input_token_details?.audio!==void 0)&&{audio:(this.usage_metadata?.input_token_details?.audio??0)+(e.usage_metadata?.input_token_details?.audio??0)},...(this.usage_metadata?.input_token_details?.cache_read!==void 0||e.usage_metadata?.input_token_details?.cache_read!==void 0)&&{cache_read:(this.usage_metadata?.input_token_details?.cache_read??0)+(e.usage_metadata?.input_token_details?.cache_read??0)},...(this.usage_metadata?.input_token_details?.cache_creation!==void 0||e.usage_metadata?.input_token_details?.cache_creation!==void 0)&&{cache_creation:(this.usage_metadata?.input_token_details?.cache_creation??0)+(e.usage_metadata?.input_token_details?.cache_creation??0)}},a={...(this.usage_metadata?.output_token_details?.audio!==void 0||e.usage_metadata?.output_token_details?.audio!==void 0)&&{audio:(this.usage_metadata?.output_token_details?.audio??0)+(e.usage_metadata?.output_token_details?.audio??0)},...(this.usage_metadata?.output_token_details?.reasoning!==void 0||e.usage_metadata?.output_token_details?.reasoning!==void 0)&&{reasoning:(this.usage_metadata?.output_token_details?.reasoning??0)+(e.usage_metadata?.output_token_details?.reasoning??0)}},s=this.usage_metadata??{input_tokens:0,output_tokens:0,total_tokens:0},i=e.usage_metadata??{input_tokens:0,output_tokens:0,total_tokens:0},o={input_tokens:s.input_tokens+i.input_tokens,output_tokens:s.output_tokens+i.output_tokens,total_tokens:s.total_tokens+i.total_tokens,...Object.keys(n).length>0&&{input_token_details:n},...Object.keys(a).length>0&&{output_token_details:a}};t.usage_metadata=o}return new ce(t)}}class Ue extends le{static lc_name(){return"ChatMessage"}static _chatMessageClass(){return Ue}constructor(e,t){typeof e=="string"&&(e={content:e,role:t}),super(e),Object.defineProperty(this,"role",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.role=e.role}_getType(){return"generic"}static isInstance(e){return e._getType()==="generic"}get _printableFields(){return{...super._printableFields,role:this.role}}}class vt extends Te{static lc_name(){return"ChatMessageChunk"}constructor(e,t){typeof e=="string"&&(e={content:e,role:t}),super(e),Object.defineProperty(this,"role",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.role=e.role}_getType(){return"generic"}concat(e){return new vt({content:ke(this.content,e.content),additional_kwargs:L(this.additional_kwargs,e.additional_kwargs),response_metadata:L(this.response_metadata,e.response_metadata),role:this.role,id:this.id??e.id})}get _printableFields(){return{...super._printableFields,role:this.role}}}class Ot extends Te{static lc_name(){return"FunctionMessageChunk"}_getType(){return"function"}concat(e){return new Ot({content:ke(this.content,e.content),additional_kwargs:L(this.additional_kwargs,e.additional_kwargs),response_metadata:L(this.response_metadata,e.response_metadata),name:this.name??"",id:this.id??e.id})}}class ze extends le{static lc_name(){return"HumanMessage"}_getType(){return"human"}constructor(e,t){super(e,t)}}class kt extends Te{static lc_name(){return"HumanMessageChunk"}_getType(){return"human"}constructor(e,t){super(e,t)}concat(e){return new kt({content:ke(this.content,e.content),additional_kwargs:L(this.additional_kwargs,e.additional_kwargs),response_metadata:L(this.response_metadata,e.response_metadata),id:this.id??e.id})}}class $t extends le{static lc_name(){return"SystemMessage"}_getType(){return"system"}constructor(e,t){super(e,t)}}class Tt extends Te{static lc_name(){return"SystemMessageChunk"}_getType(){return"system"}constructor(e,t){super(e,t)}concat(e){return new Tt({content:ke(this.content,e.content),additional_kwargs:L(this.additional_kwargs,e.additional_kwargs),response_metadata:L(this.response_metadata,e.response_metadata),id:this.id??e.id})}}function ln(r,e){return r.lc_error_code=e,r.message=`${r.message}

Troubleshooting URL: https://js.langchain.com/docs/troubleshooting/errors/${e}/
`,r}function cn(r){return!!(r&&typeof r=="object"&&"type"in r&&r.type==="tool_call")}class lr extends Error{constructor(e,t){super(e),Object.defineProperty(this,"output",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.output=t}}function cr(r){return cn(r)?r:typeof r.id=="string"&&r.type==="function"&&typeof r.function=="object"&&r.function!==null&&"arguments"in r.function&&typeof r.function.arguments=="string"&&"name"in r.function&&typeof r.function.name=="string"?{id:r.id,args:JSON.parse(r.function.arguments),name:r.function.name,type:"tool_call"}:r}function dr(r){return typeof r=="object"&&r!=null&&r.lc===1&&Array.isArray(r.id)&&r.kwargs!=null&&typeof r.kwargs=="object"}function Ze(r){let e,t;if(dr(r)){const n=r.id.at(-1);n==="HumanMessage"||n==="HumanMessageChunk"?e="user":n==="AIMessage"||n==="AIMessageChunk"?e="assistant":n==="SystemMessage"||n==="SystemMessageChunk"?e="system":n==="FunctionMessage"||n==="FunctionMessageChunk"?e="function":n==="ToolMessage"||n==="ToolMessageChunk"?e="tool":e="unknown",t=r.kwargs}else{const{type:n,...a}=r;e=n,t=a}if(e==="human"||e==="user")return new ze(t);if(e==="ai"||e==="assistant"){const{tool_calls:n,...a}=t;if(!Array.isArray(n))return new at(t);const s=n.map(cr);return new at({...a,tool_calls:s})}else{if(e==="system")return new $t(t);if(e==="developer")return new $t({...t,additional_kwargs:{...t.additional_kwargs,__openai_role__:"developer"}});if(e==="tool"&&"tool_call_id"in t)return new sr({...t,content:t.content,tool_call_id:t.tool_call_id,name:t.name});throw ln(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.

Received: ${JSON.stringify(r,null,2)}`),"MESSAGE_COERCION_FAILURE")}}function pe(r){if(typeof r=="string")return new ze(r);if(Ee(r))return r;if(Array.isArray(r)){const[e,t]=r;return Ze({type:e,content:t})}else if(ar(r)){const{role:e,...t}=r;return Ze({...t,type:e})}else return Ze(r)}function dn(r,e="Human",t="AI"){const n=[];for(const a of r){let s;if(a._getType()==="human")s=e;else if(a._getType()==="ai")s=t;else if(a._getType()==="system")s="System";else if(a._getType()==="function")s="Function";else if(a._getType()==="tool")s="Tool";else if(a._getType()==="generic")s=a.role;else throw new Error(`Got unsupported message type: ${a._getType()}`);const i=a.name?`${a.name}, `:"",o=typeof a.content=="string"?a.content:JSON.stringify(a.content,null,2);n.push(`${s}: ${i}${o}`)}return n.join(`
`)}function fr(r){const e=r._getType();if(e==="human")return new kt({...r});if(e==="ai"){let t={...r};return"tool_calls"in t&&(t={...t,tool_call_chunks:t.tool_calls?.map(n=>({...n,type:"tool_call_chunk",index:void 0,args:JSON.stringify(n.args)}))}),new ce({...t})}else{if(e==="system")return new Tt({...r});if(e==="function")return new Ot({...r});if(Ue.isInstance(r))return new vt({...r});throw new Error("Unknown message type.")}}/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */const hr=Object.prototype.hasOwnProperty;function it(r,e){return hr.call(r,e)}function st(r){if(Array.isArray(r)){const t=new Array(r.length);for(let n=0;n<t.length;n++)t[n]=""+n;return t}if(Object.keys)return Object.keys(r);let e=[];for(let t in r)it(r,t)&&e.push(t);return e}function B(r){switch(typeof r){case"object":return JSON.parse(JSON.stringify(r));case"undefined":return null;default:return r}}function ot(r){let e=0;const t=r.length;let n;for(;e<t;){if(n=r.charCodeAt(e),n>=48&&n<=57){e++;continue}return!1}return!0}function re(r){return r.indexOf("/")===-1&&r.indexOf("~")===-1?r:r.replace(/~/g,"~0").replace(/\//g,"~1")}function pr(r){return r.replace(/~1/g,"/").replace(/~0/g,"~")}function ut(r){if(r===void 0)return!0;if(r){if(Array.isArray(r)){for(let t=0,n=r.length;t<n;t++)if(ut(r[t]))return!0}else if(typeof r=="object"){const t=st(r),n=t.length;for(var e=0;e<n;e++)if(ut(r[t[e]]))return!0}}return!1}function Ft(r,e){const t=[r];for(const n in e){const a=typeof e[n]=="object"?JSON.stringify(e[n],null,2):e[n];typeof a<"u"&&t.push(`${n}: ${a}`)}return t.join(`
`)}class mr extends Error{constructor(e,t,n,a,s){super(Ft(e,{name:t,index:n,operation:a,tree:s})),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"index",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"operation",{enumerable:!0,configurable:!0,writable:!0,value:a}),Object.defineProperty(this,"tree",{enumerable:!0,configurable:!0,writable:!0,value:s}),Object.setPrototypeOf(this,new.target.prototype),this.message=Ft(e,{name:t,index:n,operation:a,tree:s})}}const T=mr,ae={add:function(r,e,t){return r[e]=this.value,{newDocument:t}},remove:function(r,e,t){var n=r[e];return delete r[e],{newDocument:t,removed:n}},replace:function(r,e,t){var n=r[e];return r[e]=this.value,{newDocument:t,removed:n}},move:function(r,e,t){let n=lt(t,this.path);n&&(n=B(n));const a=ge(t,{op:"remove",path:this.from}).removed;return ge(t,{op:"add",path:this.path,value:a}),{newDocument:t,removed:n}},copy:function(r,e,t){const n=lt(t,this.from);return ge(t,{op:"add",path:this.path,value:B(n)}),{newDocument:t}},test:function(r,e,t){return{newDocument:t,test:Fe(r[e],this.value)}},_get:function(r,e,t){return this.value=r[e],{newDocument:t}}};var gr={add:function(r,e,t){return ot(e)?r.splice(e,0,this.value):r[e]=this.value,{newDocument:t,index:e}},remove:function(r,e,t){var n=r.splice(e,1);return{newDocument:t,removed:n[0]}},replace:function(r,e,t){var n=r[e];return r[e]=this.value,{newDocument:t,removed:n}},move:ae.move,copy:ae.copy,test:ae.test,_get:ae._get};function lt(r,e){if(e=="")return r;var t={op:"_get",path:e};return ge(r,t),t.value}function ge(r,e,t=!1,n=!0,a=!0,s=0){if(t&&(typeof t=="function"?t(e,0,r,e.path):ct(e,0)),e.path===""){let i={newDocument:r};if(e.op==="add")return i.newDocument=e.value,i;if(e.op==="replace")return i.newDocument=e.value,i.removed=r,i;if(e.op==="move"||e.op==="copy")return i.newDocument=lt(r,e.from),e.op==="move"&&(i.removed=r),i;if(e.op==="test"){if(i.test=Fe(r,e.value),i.test===!1)throw new T("Test operation failed","TEST_OPERATION_FAILED",s,e,r);return i.newDocument=r,i}else{if(e.op==="remove")return i.removed=r,i.newDocument=null,i;if(e.op==="_get")return e.value=r,i;if(t)throw new T("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",s,e,r);return i}}else{n||(r=B(r));const o=(e.path||"").split("/");let u=r,l=1,c=o.length,f,d,h;for(typeof t=="function"?h=t:h=ct;;){if(d=o[l],d&&d.indexOf("~")!=-1&&(d=pr(d)),a&&(d=="__proto__"||d=="prototype"&&l>0&&o[l-1]=="constructor"))throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");if(t&&f===void 0&&(u[d]===void 0?f=o.slice(0,l).join("/"):l==c-1&&(f=e.path),f!==void 0&&h(e,0,r,f)),l++,Array.isArray(u)){if(d==="-")d=u.length;else{if(t&&!ot(d))throw new T("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index","OPERATION_PATH_ILLEGAL_ARRAY_INDEX",s,e,r);ot(d)&&(d=~~d)}if(l>=c){if(t&&e.op==="add"&&d>u.length)throw new T("The specified index MUST NOT be greater than the number of elements in the array","OPERATION_VALUE_OUT_OF_BOUNDS",s,e,r);const p=gr[e.op].call(e,u,d,r);if(p.test===!1)throw new T("Test operation failed","TEST_OPERATION_FAILED",s,e,r);return p}}else if(l>=c){const p=ae[e.op].call(e,u,d,r);if(p.test===!1)throw new T("Test operation failed","TEST_OPERATION_FAILED",s,e,r);return p}if(u=u[d],t&&l<c&&(!u||typeof u!="object"))throw new T("Cannot perform operation at the desired path","OPERATION_PATH_UNRESOLVABLE",s,e,r)}}}function $e(r,e,t,n=!0,a=!0){if(t&&!Array.isArray(e))throw new T("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");n||(r=B(r));const s=new Array(e.length);for(let i=0,o=e.length;i<o;i++)s[i]=ge(r,e[i],t,!0,a,i),r=s[i].newDocument;return s.newDocument=r,s}function ct(r,e,t,n){if(typeof r!="object"||r===null||Array.isArray(r))throw new T("Operation is not an object","OPERATION_NOT_AN_OBJECT",e,r,t);if(ae[r.op]){if(typeof r.path!="string")throw new T("Operation `path` property is not a string","OPERATION_PATH_INVALID",e,r,t);if(r.path.indexOf("/")!==0&&r.path.length>0)throw new T('Operation `path` property must start with "/"',"OPERATION_PATH_INVALID",e,r,t);if((r.op==="move"||r.op==="copy")&&typeof r.from!="string")throw new T("Operation `from` property is not present (applicable in `move` and `copy` operations)","OPERATION_FROM_REQUIRED",e,r,t);if((r.op==="add"||r.op==="replace"||r.op==="test")&&r.value===void 0)throw new T("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_REQUIRED",e,r,t);if((r.op==="add"||r.op==="replace"||r.op==="test")&&ut(r.value))throw new T("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)","OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED",e,r,t);if(t){if(r.op=="add"){var a=r.path.split("/").length,s=n.split("/").length;if(a!==s+1&&a!==s)throw new T("Cannot perform an `add` operation at the desired path","OPERATION_PATH_CANNOT_ADD",e,r,t)}else if(r.op==="replace"||r.op==="remove"||r.op==="_get"){if(r.path!==n)throw new T("Cannot perform the operation at a path that does not exist","OPERATION_PATH_UNRESOLVABLE",e,r,t)}else if(r.op==="move"||r.op==="copy"){var i={op:"_get",path:r.from,value:void 0},o=br([i],t);if(o&&o.name==="OPERATION_PATH_UNRESOLVABLE")throw new T("Cannot perform the operation from a path that does not exist","OPERATION_FROM_UNRESOLVABLE",e,r,t)}}}else throw new T("Operation `op` property is not one of operations defined in RFC-6902","OPERATION_OP_INVALID",e,r,t)}function br(r,e,t){try{if(!Array.isArray(r))throw new T("Patch sequence must be an array","SEQUENCE_NOT_AN_ARRAY");if(e)$e(B(e),B(r),t||!0);else{t=t||ct;for(var n=0;n<r.length;n++)t(r[n],n,e,void 0)}}catch(a){if(a instanceof T)return a;throw a}}function Fe(r,e){if(r===e)return!0;if(r&&e&&typeof r=="object"&&typeof e=="object"){var t=Array.isArray(r),n=Array.isArray(e),a,s,i;if(t&&n){if(s=r.length,s!=e.length)return!1;for(a=s;a--!==0;)if(!Fe(r[a],e[a]))return!1;return!0}if(t!=n)return!1;var o=Object.keys(r);if(s=o.length,s!==Object.keys(e).length)return!1;for(a=s;a--!==0;)if(!e.hasOwnProperty(o[a]))return!1;for(a=s;a--!==0;)if(i=o[a],!Fe(r[i],e[i]))return!1;return!0}return r!==r&&e!==e}/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2013-2021 Joachim Wester
 * MIT license
 */function fn(r,e,t,n,a){if(e!==r){typeof e.toJSON=="function"&&(e=e.toJSON());for(var s=st(e),i=st(r),o=!1,u=i.length-1;u>=0;u--){var l=i[u],c=r[l];if(it(e,l)&&!(e[l]===void 0&&c!==void 0&&Array.isArray(e)===!1)){var f=e[l];typeof c=="object"&&c!=null&&typeof f=="object"&&f!=null&&Array.isArray(c)===Array.isArray(f)?fn(c,f,t,n+"/"+re(l),a):c!==f&&(a&&t.push({op:"test",path:n+"/"+re(l),value:B(c)}),t.push({op:"replace",path:n+"/"+re(l),value:B(f)}))}else Array.isArray(r)===Array.isArray(e)?(a&&t.push({op:"test",path:n+"/"+re(l),value:B(c)}),t.push({op:"remove",path:n+"/"+re(l)}),o=!0):(a&&t.push({op:"test",path:n,value:r}),t.push({op:"replace",path:n,value:e}))}if(!(!o&&s.length==i.length))for(var u=0;u<s.length;u++){var l=s[u];!it(r,l)&&e[l]!==void 0&&t.push({op:"add",path:n+"/"+re(l),value:B(e[l])})}}}function yr(r,e,t=!1){var n=[];return fn(r,e,n,"",t),n}class _r{}function wr(r){return"lc_prefer_streaming"in r&&r.lc_prefer_streaming}class Se extends _r{get lc_namespace(){return["langchain_core","callbacks",this.name]}get lc_secrets(){}get lc_attributes(){}get lc_aliases(){}get lc_serializable_keys(){}static lc_name(){return this.name}get lc_id(){return[...this.lc_namespace,un(this.constructor)]}constructor(e){super(),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lc_kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"ignoreLLM",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreChain",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreAgent",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreRetriever",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"ignoreCustomEvent",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"raiseError",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"awaitHandlers",{enumerable:!0,configurable:!0,writable:!0,value:X("LANGCHAIN_CALLBACKS_BACKGROUND")==="false"}),this.lc_kwargs=e||{},e&&(this.ignoreLLM=e.ignoreLLM??this.ignoreLLM,this.ignoreChain=e.ignoreChain??this.ignoreChain,this.ignoreAgent=e.ignoreAgent??this.ignoreAgent,this.ignoreRetriever=e.ignoreRetriever??this.ignoreRetriever,this.ignoreCustomEvent=e.ignoreCustomEvent??this.ignoreCustomEvent,this.raiseError=e.raiseError??this.raiseError,this.awaitHandlers=this.raiseError||(e._awaitHandler??this.awaitHandlers))}copy(){return new this.constructor(this)}toJSON(){return te.prototype.toJSON.call(this)}toJSONNotImplemented(){return te.prototype.toJSONNotImplemented.call(this)}static fromMethods(e){class t extends Se{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:z()}),Object.assign(this,e)}}return new t}}const vr=r=>{const e=r;return e!==void 0&&typeof e.copy=="function"&&typeof e.name=="string"&&typeof e.awaitHandlers=="boolean"},Or=r=>{if(r)return r.events=r.events??[],r.child_runs=r.child_runs??[],r};function dt(r,e){if(r)return new gt({...r,start_time:r._serialized_start_time??r.start_time,parent_run:dt(e),child_runs:r.child_runs.map(t=>dt(t)).filter(t=>t!==void 0),extra:{...r.extra,runtime:qn()},tracingEnabled:!1})}function Ye(r,e){return r&&!Array.isArray(r)&&typeof r=="object"?r:{[e]:r}}function he(r){return typeof r._addRunToRunMap=="function"}class Ce extends Se{constructor(e){super(...arguments),Object.defineProperty(this,"runMap",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),Object.defineProperty(this,"runTreeMap",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),Object.defineProperty(this,"usesRunTreeMap",{enumerable:!0,configurable:!0,writable:!0,value:!1})}copy(){return this}getRunById(e){if(e!==void 0)return this.usesRunTreeMap?Or(this.runTreeMap.get(e)):this.runMap.get(e)}stringifyError(e){return e instanceof Error?e.message+(e?.stack?`

${e.stack}`:""):typeof e=="string"?e:`${e}`}_addChildRun(e,t){e.child_runs.push(t)}_addRunToRunMap(e){const{dottedOrder:t,microsecondPrecisionDatestring:n}=Pn(new Date(e.start_time).getTime(),e.id,e.execution_order),a={...e},s=this.getRunById(a.parent_run_id);if(a.parent_run_id!==void 0?s&&(this._addChildRun(s,a),s.child_execution_order=Math.max(s.child_execution_order,a.child_execution_order),a.trace_id=s.trace_id,s.dotted_order!==void 0&&(a.dotted_order=[s.dotted_order,t].join("."),a._serialized_start_time=n)):(a.trace_id=a.id,a.dotted_order=t,a._serialized_start_time=n),this.usesRunTreeMap){const i=dt(a,s);i!==void 0&&this.runTreeMap.set(a.id,i)}else this.runMap.set(a.id,a);return a}async _endTrace(e){const t=e.parent_run_id!==void 0&&this.getRunById(e.parent_run_id);t?t.child_execution_order=Math.max(t.child_execution_order,e.child_execution_order):await this.persistRun(e),await this.onRunUpdate?.(e),this.usesRunTreeMap?this.runTreeMap.delete(e.id):this.runMap.delete(e.id)}_getExecutionOrder(e){const t=e!==void 0&&this.getRunById(e);return t?t.child_execution_order+1:1}_createRunForLLMStart(e,t,n,a,s,i,o,u){const l=this._getExecutionOrder(a),c=Date.now(),f=o?{...s,metadata:o}:s,d={id:n,name:u??e.id[e.id.length-1],parent_run_id:a,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:{prompts:t},execution_order:l,child_runs:[],child_execution_order:l,run_type:"llm",extra:f??{},tags:i||[]};return this._addRunToRunMap(d)}async handleLLMStart(e,t,n,a,s,i,o,u){const l=this.getRunById(n)??this._createRunForLLMStart(e,t,n,a,s,i,o,u);return await this.onRunCreate?.(l),await this.onLLMStart?.(l),l}_createRunForChatModelStart(e,t,n,a,s,i,o,u){const l=this._getExecutionOrder(a),c=Date.now(),f=o?{...s,metadata:o}:s,d={id:n,name:u??e.id[e.id.length-1],parent_run_id:a,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:{messages:t},execution_order:l,child_runs:[],child_execution_order:l,run_type:"llm",extra:f??{},tags:i||[]};return this._addRunToRunMap(d)}async handleChatModelStart(e,t,n,a,s,i,o,u){const l=this.getRunById(n)??this._createRunForChatModelStart(e,t,n,a,s,i,o,u);return await this.onRunCreate?.(l),await this.onLLMStart?.(l),l}async handleLLMEnd(e,t,n,a,s){const i=this.getRunById(t);if(!i||i?.run_type!=="llm")throw new Error("No LLM run to end.");return i.end_time=Date.now(),i.outputs=e,i.events.push({name:"end",time:new Date(i.end_time).toISOString()}),i.extra={...i.extra,...s},await this.onLLMEnd?.(i),await this._endTrace(i),i}async handleLLMError(e,t,n,a,s){const i=this.getRunById(t);if(!i||i?.run_type!=="llm")throw new Error("No LLM run to end.");return i.end_time=Date.now(),i.error=this.stringifyError(e),i.events.push({name:"error",time:new Date(i.end_time).toISOString()}),i.extra={...i.extra,...s},await this.onLLMError?.(i),await this._endTrace(i),i}_createRunForChainStart(e,t,n,a,s,i,o,u){const l=this._getExecutionOrder(a),c=Date.now(),f={id:n,name:u??e.id[e.id.length-1],parent_run_id:a,start_time:c,serialized:e,events:[{name:"start",time:new Date(c).toISOString()}],inputs:t,execution_order:l,child_execution_order:l,run_type:o??"chain",child_runs:[],extra:i?{metadata:i}:{},tags:s||[]};return this._addRunToRunMap(f)}async handleChainStart(e,t,n,a,s,i,o,u){const l=this.getRunById(n)??this._createRunForChainStart(e,t,n,a,s,i,o,u);return await this.onRunCreate?.(l),await this.onChainStart?.(l),l}async handleChainEnd(e,t,n,a,s){const i=this.getRunById(t);if(!i)throw new Error("No chain run to end.");return i.end_time=Date.now(),i.outputs=Ye(e,"output"),i.events.push({name:"end",time:new Date(i.end_time).toISOString()}),s?.inputs!==void 0&&(i.inputs=Ye(s.inputs,"input")),await this.onChainEnd?.(i),await this._endTrace(i),i}async handleChainError(e,t,n,a,s){const i=this.getRunById(t);if(!i)throw new Error("No chain run to end.");return i.end_time=Date.now(),i.error=this.stringifyError(e),i.events.push({name:"error",time:new Date(i.end_time).toISOString()}),s?.inputs!==void 0&&(i.inputs=Ye(s.inputs,"input")),await this.onChainError?.(i),await this._endTrace(i),i}_createRunForToolStart(e,t,n,a,s,i,o){const u=this._getExecutionOrder(a),l=Date.now(),c={id:n,name:o??e.id[e.id.length-1],parent_run_id:a,start_time:l,serialized:e,events:[{name:"start",time:new Date(l).toISOString()}],inputs:{input:t},execution_order:u,child_execution_order:u,run_type:"tool",child_runs:[],extra:i?{metadata:i}:{},tags:s||[]};return this._addRunToRunMap(c)}async handleToolStart(e,t,n,a,s,i,o){const u=this.getRunById(n)??this._createRunForToolStart(e,t,n,a,s,i,o);return await this.onRunCreate?.(u),await this.onToolStart?.(u),u}async handleToolEnd(e,t){const n=this.getRunById(t);if(!n||n?.run_type!=="tool")throw new Error("No tool run to end");return n.end_time=Date.now(),n.outputs={output:e},n.events.push({name:"end",time:new Date(n.end_time).toISOString()}),await this.onToolEnd?.(n),await this._endTrace(n),n}async handleToolError(e,t){const n=this.getRunById(t);if(!n||n?.run_type!=="tool")throw new Error("No tool run to end");return n.end_time=Date.now(),n.error=this.stringifyError(e),n.events.push({name:"error",time:new Date(n.end_time).toISOString()}),await this.onToolError?.(n),await this._endTrace(n),n}async handleAgentAction(e,t){const n=this.getRunById(t);if(!n||n?.run_type!=="chain")return;const a=n;a.actions=a.actions||[],a.actions.push(e),a.events.push({name:"agent_action",time:new Date().toISOString(),kwargs:{action:e}}),await this.onAgentAction?.(n)}async handleAgentEnd(e,t){const n=this.getRunById(t);!n||n?.run_type!=="chain"||(n.events.push({name:"agent_end",time:new Date().toISOString(),kwargs:{action:e}}),await this.onAgentEnd?.(n))}_createRunForRetrieverStart(e,t,n,a,s,i,o){const u=this._getExecutionOrder(a),l=Date.now(),c={id:n,name:o??e.id[e.id.length-1],parent_run_id:a,start_time:l,serialized:e,events:[{name:"start",time:new Date(l).toISOString()}],inputs:{query:t},execution_order:u,child_execution_order:u,run_type:"retriever",child_runs:[],extra:i?{metadata:i}:{},tags:s||[]};return this._addRunToRunMap(c)}async handleRetrieverStart(e,t,n,a,s,i,o){const u=this.getRunById(n)??this._createRunForRetrieverStart(e,t,n,a,s,i,o);return await this.onRunCreate?.(u),await this.onRetrieverStart?.(u),u}async handleRetrieverEnd(e,t){const n=this.getRunById(t);if(!n||n?.run_type!=="retriever")throw new Error("No retriever run to end");return n.end_time=Date.now(),n.outputs={documents:e},n.events.push({name:"end",time:new Date(n.end_time).toISOString()}),await this.onRetrieverEnd?.(n),await this._endTrace(n),n}async handleRetrieverError(e,t){const n=this.getRunById(t);if(!n||n?.run_type!=="retriever")throw new Error("No retriever run to end");return n.end_time=Date.now(),n.error=this.stringifyError(e),n.events.push({name:"error",time:new Date(n.end_time).toISOString()}),await this.onRetrieverError?.(n),await this._endTrace(n),n}async handleText(e,t){const n=this.getRunById(t);!n||n?.run_type!=="chain"||(n.events.push({name:"text",time:new Date().toISOString(),kwargs:{text:e}}),await this.onText?.(n))}async handleLLMNewToken(e,t,n,a,s,i){const o=this.getRunById(n);if(!o||o?.run_type!=="llm")throw new Error('Invalid "runId" provided to "handleLLMNewToken" callback.');return o.events.push({name:"new_token",time:new Date().toISOString(),kwargs:{token:e,idx:t,chunk:i?.chunk}}),await this.onLLMNewToken?.(o,e,{chunk:i?.chunk}),o}}var Ne={exports:{}};Ne.exports;var Dt;function kr(){return Dt||(Dt=1,(function(r){const t=(s=0)=>i=>`\x1B[${38+s};5;${i}m`,n=(s=0)=>(i,o,u)=>`\x1B[${38+s};2;${i};${o};${u}m`;function a(){const s=new Map,i={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};i.color.gray=i.color.blackBright,i.bgColor.bgGray=i.bgColor.bgBlackBright,i.color.grey=i.color.blackBright,i.bgColor.bgGrey=i.bgColor.bgBlackBright;for(const[o,u]of Object.entries(i)){for(const[l,c]of Object.entries(u))i[l]={open:`\x1B[${c[0]}m`,close:`\x1B[${c[1]}m`},u[l]=i[l],s.set(c[0],c[1]);Object.defineProperty(i,o,{value:u,enumerable:!1})}return Object.defineProperty(i,"codes",{value:s,enumerable:!1}),i.color.close="\x1B[39m",i.bgColor.close="\x1B[49m",i.color.ansi256=t(),i.color.ansi16m=n(),i.bgColor.ansi256=t(10),i.bgColor.ansi16m=n(10),Object.defineProperties(i,{rgbToAnsi256:{value:(o,u,l)=>o===u&&u===l?o<8?16:o>248?231:Math.round((o-8)/247*24)+232:16+36*Math.round(o/255*5)+6*Math.round(u/255*5)+Math.round(l/255*5),enumerable:!1},hexToRgb:{value:o=>{const u=/(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(o.toString(16));if(!u)return[0,0,0];let{colorString:l}=u.groups;l.length===3&&(l=l.split("").map(f=>f+f).join(""));const c=Number.parseInt(l,16);return[c>>16&255,c>>8&255,c&255]},enumerable:!1},hexToAnsi256:{value:o=>i.rgbToAnsi256(...i.hexToRgb(o)),enumerable:!1}}),i}Object.defineProperty(r,"exports",{enumerable:!0,get:a})})(Ne)),Ne.exports}var Tr=kr();const hn=xn(Tr);function R(r,e){return`${r.open}${e}${r.close}`}function M(r,e){try{return JSON.stringify(r,null,2)}catch{return e}}function Bt(r){return typeof r=="string"?r.trim():r==null?r:M(r,r.toString())}function J(r){if(!r.end_time)return"";const e=r.end_time-r.start_time;return e<1e3?`${e}ms`:`${(e/1e3).toFixed(2)}s`}const{color:A}=hn;class Ht extends Ce{constructor(){super(...arguments),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"console_callback_handler"})}persistRun(e){return Promise.resolve()}getParents(e){const t=[];let n=e;for(;n.parent_run_id;){const a=this.runMap.get(n.parent_run_id);if(a)t.push(a),n=a;else break}return t}getBreadcrumbs(e){const n=[...this.getParents(e).reverse(),e].map((a,s,i)=>{const o=`${a.execution_order}:${a.run_type}:${a.name}`;return s===i.length-1?R(hn.bold,o):o}).join(" > ");return R(A.grey,n)}onChainStart(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.green,"[chain/start]")} [${t}] Entering Chain run with input: ${M(e.inputs,"[inputs]")}`)}onChainEnd(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.cyan,"[chain/end]")} [${t}] [${J(e)}] Exiting Chain run with output: ${M(e.outputs,"[outputs]")}`)}onChainError(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.red,"[chain/error]")} [${t}] [${J(e)}] Chain run errored with error: ${M(e.error,"[error]")}`)}onLLMStart(e){const t=this.getBreadcrumbs(e),n="prompts"in e.inputs?{prompts:e.inputs.prompts.map(a=>a.trim())}:e.inputs;console.log(`${R(A.green,"[llm/start]")} [${t}] Entering LLM run with input: ${M(n,"[inputs]")}`)}onLLMEnd(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.cyan,"[llm/end]")} [${t}] [${J(e)}] Exiting LLM run with output: ${M(e.outputs,"[response]")}`)}onLLMError(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.red,"[llm/error]")} [${t}] [${J(e)}] LLM run errored with error: ${M(e.error,"[error]")}`)}onToolStart(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.green,"[tool/start]")} [${t}] Entering Tool run with input: "${Bt(e.inputs.input)}"`)}onToolEnd(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.cyan,"[tool/end]")} [${t}] [${J(e)}] Exiting Tool run with output: "${Bt(e.outputs?.output)}"`)}onToolError(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.red,"[tool/error]")} [${t}] [${J(e)}] Tool run errored with error: ${M(e.error,"[error]")}`)}onRetrieverStart(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.green,"[retriever/start]")} [${t}] Entering Retriever run with input: ${M(e.inputs,"[inputs]")}`)}onRetrieverEnd(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.cyan,"[retriever/end]")} [${t}] [${J(e)}] Exiting Retriever run with output: ${M(e.outputs,"[outputs]")}`)}onRetrieverError(e){const t=this.getBreadcrumbs(e);console.log(`${R(A.red,"[retriever/error]")} [${t}] [${J(e)}] Retriever run errored with error: ${M(e.error,"[error]")}`)}onAgentAction(e){const t=e,n=this.getBreadcrumbs(e);console.log(`${R(A.blue,"[agent/action]")} [${n}] Agent selected action: ${M(t.actions[t.actions.length-1],"[action]")}`)}}let Qe;const Er=()=>{if(Qe===void 0){const r=X("LANGCHAIN_CALLBACKS_BACKGROUND")==="false"?{blockOnRootRunFinalization:!0}:{};Qe=new In(r)}return Qe};class be extends Ce{constructor(e={}){super(e),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"langchain_tracer"}),Object.defineProperty(this,"projectName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"exampleId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"client",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"replicas",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usesRunTreeMap",{enumerable:!0,configurable:!0,writable:!0,value:!0});const{exampleId:t,projectName:n,client:a,replicas:s}=e;this.projectName=n??Rn(),this.replicas=s,this.exampleId=t,this.client=a??Er();const i=be.getTraceableRunTree();i&&this.updateFromRunTree(i)}async persistRun(e){}async onRunCreate(e){await this.getRunTreeWithTracingConfig(e.id)?.postRun()}async onRunUpdate(e){await this.getRunTreeWithTracingConfig(e.id)?.patchRun()}getRun(e){return this.runTreeMap.get(e)}updateFromRunTree(e){this.runTreeMap.set(e.id,e);let t=e;const n=new Set;for(;t.parent_run&&!(n.has(t.id)||(n.add(t.id),!t.parent_run));)t=t.parent_run;n.clear();const a=[t];for(;a.length>0;){const s=a.shift();!s||n.has(s.id)||(n.add(s.id),this.runTreeMap.set(s.id,s),s.child_runs&&a.push(...s.child_runs))}this.client=e.client??this.client,this.replicas=e.replicas??this.replicas,this.projectName=e.project_name??this.projectName,this.exampleId=e.reference_example_id??this.exampleId}getRunTreeWithTracingConfig(e){const t=this.runTreeMap.get(e);if(t)return new gt({...t,client:this.client,project_name:this.projectName,replicas:this.replicas,reference_example_id:this.exampleId,tracingEnabled:!0})}static getTraceableRunTree(){try{return An(!0)}catch{return}}}const pn=Symbol.for("ls:tracing_async_local_storage"),Me=Symbol.for("lc:context_variables"),Sr=r=>{globalThis[pn]=r},we=()=>globalThis[pn];let ye;function Cr(){const r="default"in ie?ie.default:ie;return new r({autoStart:!0,concurrency:1})}function Pr(){return typeof ye>"u"&&(ye=Cr()),ye}async function E(r,e){if(e===!0){const t=we();t!==void 0?await t.run(void 0,async()=>r()):await r()}else ye=Pr(),ye.add(async()=>{const t=we();t!==void 0?await t.run(void 0,async()=>r()):await r()})}const xr=r=>!!["LANGSMITH_TRACING_V2","LANGCHAIN_TRACING_V2","LANGSMITH_TRACING","LANGCHAIN_TRACING"].find(t=>X(t)==="true");function mn(r){const e=we();return e===void 0?void 0:e.getStore()?.[Me]?.[r]}const Ir=Symbol("lc:configure_hooks"),Rr=()=>mn(Ir)||[];class Ar{setHandler(e){return this.setHandlers([e])}}class Ge{constructor(e,t,n,a,s,i,o,u){Object.defineProperty(this,"runId",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:a}),Object.defineProperty(this,"inheritableTags",{enumerable:!0,configurable:!0,writable:!0,value:s}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:i}),Object.defineProperty(this,"inheritableMetadata",{enumerable:!0,configurable:!0,writable:!0,value:o}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:u})}get parentRunId(){return this._parentRunId}async handleText(e){await Promise.all(this.handlers.map(t=>E(async()=>{try{await t.handleText?.(e,this.runId,this._parentRunId,this.tags)}catch(n){if((t.raiseError?console.error:console.warn)(`Error in handler ${t.constructor.name}, handleText: ${n}`),t.raiseError)throw n}},t.awaitHandlers)))}async handleCustomEvent(e,t,n,a,s){await Promise.all(this.handlers.map(i=>E(async()=>{try{await i.handleCustomEvent?.(e,t,this.runId,this.tags,this.metadata)}catch(o){if((i.raiseError?console.error:console.warn)(`Error in handler ${i.constructor.name}, handleCustomEvent: ${o}`),i.raiseError)throw o}},i.awaitHandlers)))}}class jr extends Ge{getChild(e){const t=new j(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleRetrieverEnd(e){await Promise.all(this.handlers.map(t=>E(async()=>{if(!t.ignoreRetriever)try{await t.handleRetrieverEnd?.(e,this.runId,this._parentRunId,this.tags)}catch(n){if((t.raiseError?console.error:console.warn)(`Error in handler ${t.constructor.name}, handleRetriever`),t.raiseError)throw n}},t.awaitHandlers)))}async handleRetrieverError(e){await Promise.all(this.handlers.map(t=>E(async()=>{if(!t.ignoreRetriever)try{await t.handleRetrieverError?.(e,this.runId,this._parentRunId,this.tags)}catch(n){if((t.raiseError?console.error:console.warn)(`Error in handler ${t.constructor.name}, handleRetrieverError: ${n}`),t.raiseError)throw e}},t.awaitHandlers)))}}class Ut extends Ge{async handleLLMNewToken(e,t,n,a,s,i){await Promise.all(this.handlers.map(o=>E(async()=>{if(!o.ignoreLLM)try{await o.handleLLMNewToken?.(e,t??{prompt:0,completion:0},this.runId,this._parentRunId,this.tags,i)}catch(u){if((o.raiseError?console.error:console.warn)(`Error in handler ${o.constructor.name}, handleLLMNewToken: ${u}`),o.raiseError)throw u}},o.awaitHandlers)))}async handleLLMError(e,t,n,a,s){await Promise.all(this.handlers.map(i=>E(async()=>{if(!i.ignoreLLM)try{await i.handleLLMError?.(e,this.runId,this._parentRunId,this.tags,s)}catch(o){if((i.raiseError?console.error:console.warn)(`Error in handler ${i.constructor.name}, handleLLMError: ${o}`),i.raiseError)throw o}},i.awaitHandlers)))}async handleLLMEnd(e,t,n,a,s){await Promise.all(this.handlers.map(i=>E(async()=>{if(!i.ignoreLLM)try{await i.handleLLMEnd?.(e,this.runId,this._parentRunId,this.tags,s)}catch(o){if((i.raiseError?console.error:console.warn)(`Error in handler ${i.constructor.name}, handleLLMEnd: ${o}`),i.raiseError)throw o}},i.awaitHandlers)))}}class Nr extends Ge{getChild(e){const t=new j(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleChainError(e,t,n,a,s){await Promise.all(this.handlers.map(i=>E(async()=>{if(!i.ignoreChain)try{await i.handleChainError?.(e,this.runId,this._parentRunId,this.tags,s)}catch(o){if((i.raiseError?console.error:console.warn)(`Error in handler ${i.constructor.name}, handleChainError: ${o}`),i.raiseError)throw o}},i.awaitHandlers)))}async handleChainEnd(e,t,n,a,s){await Promise.all(this.handlers.map(i=>E(async()=>{if(!i.ignoreChain)try{await i.handleChainEnd?.(e,this.runId,this._parentRunId,this.tags,s)}catch(o){if((i.raiseError?console.error:console.warn)(`Error in handler ${i.constructor.name}, handleChainEnd: ${o}`),i.raiseError)throw o}},i.awaitHandlers)))}async handleAgentAction(e){await Promise.all(this.handlers.map(t=>E(async()=>{if(!t.ignoreAgent)try{await t.handleAgentAction?.(e,this.runId,this._parentRunId,this.tags)}catch(n){if((t.raiseError?console.error:console.warn)(`Error in handler ${t.constructor.name}, handleAgentAction: ${n}`),t.raiseError)throw n}},t.awaitHandlers)))}async handleAgentEnd(e){await Promise.all(this.handlers.map(t=>E(async()=>{if(!t.ignoreAgent)try{await t.handleAgentEnd?.(e,this.runId,this._parentRunId,this.tags)}catch(n){if((t.raiseError?console.error:console.warn)(`Error in handler ${t.constructor.name}, handleAgentEnd: ${n}`),t.raiseError)throw n}},t.awaitHandlers)))}}class Mr extends Ge{getChild(e){const t=new j(this.runId);return t.setHandlers(this.inheritableHandlers),t.addTags(this.inheritableTags),t.addMetadata(this.inheritableMetadata),e&&t.addTags([e],!1),t}async handleToolError(e){await Promise.all(this.handlers.map(t=>E(async()=>{if(!t.ignoreAgent)try{await t.handleToolError?.(e,this.runId,this._parentRunId,this.tags)}catch(n){if((t.raiseError?console.error:console.warn)(`Error in handler ${t.constructor.name}, handleToolError: ${n}`),t.raiseError)throw n}},t.awaitHandlers)))}async handleToolEnd(e){await Promise.all(this.handlers.map(t=>E(async()=>{if(!t.ignoreAgent)try{await t.handleToolEnd?.(e,this.runId,this._parentRunId,this.tags)}catch(n){if((t.raiseError?console.error:console.warn)(`Error in handler ${t.constructor.name}, handleToolEnd: ${n}`),t.raiseError)throw n}},t.awaitHandlers)))}}class j extends Ar{constructor(e,t){super(),Object.defineProperty(this,"handlers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"inheritableHandlers",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"inheritableTags",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"inheritableMetadata",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"callback_manager"}),Object.defineProperty(this,"_parentRunId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.handlers=t?.handlers??this.handlers,this.inheritableHandlers=t?.inheritableHandlers??this.inheritableHandlers,this.tags=t?.tags??this.tags,this.inheritableTags=t?.inheritableTags??this.inheritableTags,this.metadata=t?.metadata??this.metadata,this.inheritableMetadata=t?.inheritableMetadata??this.inheritableMetadata,this._parentRunId=e}getParentRunId(){return this._parentRunId}async handleLLMStart(e,t,n=void 0,a=void 0,s=void 0,i=void 0,o=void 0,u=void 0){return Promise.all(t.map(async(l,c)=>{const f=c===0&&n?n:z();return await Promise.all(this.handlers.map(d=>{if(!d.ignoreLLM)return he(d)&&d._createRunForLLMStart(e,[l],f,this._parentRunId,s,this.tags,this.metadata,u),E(async()=>{try{await d.handleLLMStart?.(e,[l],f,this._parentRunId,s,this.tags,this.metadata,u)}catch(h){if((d.raiseError?console.error:console.warn)(`Error in handler ${d.constructor.name}, handleLLMStart: ${h}`),d.raiseError)throw h}},d.awaitHandlers)})),new Ut(f,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}))}async handleChatModelStart(e,t,n=void 0,a=void 0,s=void 0,i=void 0,o=void 0,u=void 0){return Promise.all(t.map(async(l,c)=>{const f=c===0&&n?n:z();return await Promise.all(this.handlers.map(d=>{if(!d.ignoreLLM)return he(d)&&d._createRunForChatModelStart(e,[l],f,this._parentRunId,s,this.tags,this.metadata,u),E(async()=>{try{if(d.handleChatModelStart)await d.handleChatModelStart?.(e,[l],f,this._parentRunId,s,this.tags,this.metadata,u);else if(d.handleLLMStart){const h=dn(l);await d.handleLLMStart?.(e,[h],f,this._parentRunId,s,this.tags,this.metadata,u)}}catch(h){if((d.raiseError?console.error:console.warn)(`Error in handler ${d.constructor.name}, handleLLMStart: ${h}`),d.raiseError)throw h}},d.awaitHandlers)})),new Ut(f,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}))}async handleChainStart(e,t,n=z(),a=void 0,s=void 0,i=void 0,o=void 0){return await Promise.all(this.handlers.map(u=>{if(!u.ignoreChain)return he(u)&&u._createRunForChainStart(e,t,n,this._parentRunId,this.tags,this.metadata,a,o),E(async()=>{try{await u.handleChainStart?.(e,t,n,this._parentRunId,this.tags,this.metadata,a,o)}catch(l){if((u.raiseError?console.error:console.warn)(`Error in handler ${u.constructor.name}, handleChainStart: ${l}`),u.raiseError)throw l}},u.awaitHandlers)})),new Nr(n,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}async handleToolStart(e,t,n=z(),a=void 0,s=void 0,i=void 0,o=void 0){return await Promise.all(this.handlers.map(u=>{if(!u.ignoreAgent)return he(u)&&u._createRunForToolStart(e,t,n,this._parentRunId,this.tags,this.metadata,o),E(async()=>{try{await u.handleToolStart?.(e,t,n,this._parentRunId,this.tags,this.metadata,o)}catch(l){if((u.raiseError?console.error:console.warn)(`Error in handler ${u.constructor.name}, handleToolStart: ${l}`),u.raiseError)throw l}},u.awaitHandlers)})),new Mr(n,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}async handleRetrieverStart(e,t,n=z(),a=void 0,s=void 0,i=void 0,o=void 0){return await Promise.all(this.handlers.map(u=>{if(!u.ignoreRetriever)return he(u)&&u._createRunForRetrieverStart(e,t,n,this._parentRunId,this.tags,this.metadata,o),E(async()=>{try{await u.handleRetrieverStart?.(e,t,n,this._parentRunId,this.tags,this.metadata,o)}catch(l){if((u.raiseError?console.error:console.warn)(`Error in handler ${u.constructor.name}, handleRetrieverStart: ${l}`),u.raiseError)throw l}},u.awaitHandlers)})),new jr(n,this.handlers,this.inheritableHandlers,this.tags,this.inheritableTags,this.metadata,this.inheritableMetadata,this._parentRunId)}async handleCustomEvent(e,t,n,a,s){await Promise.all(this.handlers.map(i=>E(async()=>{if(!i.ignoreCustomEvent)try{await i.handleCustomEvent?.(e,t,n,this.tags,this.metadata)}catch(o){if((i.raiseError?console.error:console.warn)(`Error in handler ${i.constructor.name}, handleCustomEvent: ${o}`),i.raiseError)throw o}},i.awaitHandlers)))}addHandler(e,t=!0){this.handlers.push(e),t&&this.inheritableHandlers.push(e)}removeHandler(e){this.handlers=this.handlers.filter(t=>t!==e),this.inheritableHandlers=this.inheritableHandlers.filter(t=>t!==e)}setHandlers(e,t=!0){this.handlers=[],this.inheritableHandlers=[];for(const n of e)this.addHandler(n,t)}addTags(e,t=!0){this.removeTags(e),this.tags.push(...e),t&&this.inheritableTags.push(...e)}removeTags(e){this.tags=this.tags.filter(t=>!e.includes(t)),this.inheritableTags=this.inheritableTags.filter(t=>!e.includes(t))}addMetadata(e,t=!0){this.metadata={...this.metadata,...e},t&&(this.inheritableMetadata={...this.inheritableMetadata,...e})}removeMetadata(e){for(const t of Object.keys(e))delete this.metadata[t],delete this.inheritableMetadata[t]}copy(e=[],t=!0){const n=new j(this._parentRunId);for(const a of this.handlers){const s=this.inheritableHandlers.includes(a);n.addHandler(a,s)}for(const a of this.tags){const s=this.inheritableTags.includes(a);n.addTags([a],s)}for(const a of Object.keys(this.metadata)){const s=Object.keys(this.inheritableMetadata).includes(a);n.addMetadata({[a]:this.metadata[a]},s)}for(const a of e)n.handlers.filter(s=>s.name==="console_callback_handler").some(s=>s.name===a.name)||n.addHandler(a,t);return n}static fromHandlers(e){class t extends Se{constructor(){super(),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:z()}),Object.assign(this,e)}}const n=new this;return n.addHandler(new t),n}static configure(e,t,n,a,s,i,o){return this._configureSync(e,t,n,a,s,i,o)}static _configureSync(e,t,n,a,s,i,o){let u;(e||t)&&(Array.isArray(e)||!e?(u=new j,u.setHandlers(e?.map(De)??[],!0)):u=e,u=u.copy(Array.isArray(t)?t.map(De):t?.handlers,!1));const l=X("LANGCHAIN_VERBOSE")==="true"||o?.verbose,c=be.getTraceableRunTree()?.tracingEnabled||xr(),f=c||(X("LANGCHAIN_TRACING")??!1);if(l||f){if(u||(u=new j),l&&!u.handlers.some(d=>d.name===Ht.prototype.name)){const d=new Ht;u.addHandler(d,!0)}if(f&&!u.handlers.some(d=>d.name==="langchain_tracer")&&c){const d=new be;u.addHandler(d,!0),u._parentRunId=be.getTraceableRunTree()?.id??u._parentRunId}}for(const{contextVar:d,inheritable:h=!0,handlerClass:p,envVar:m}of Rr()){const g=m&&X(m)==="true"&&p;let b;const w=d!==void 0?mn(d):void 0;w&&vr(w)?b=w:g&&(b=new p({})),b!==void 0&&(u||(u=new j),u.handlers.some(v=>v.name===b.name)||u.addHandler(b,h))}return(n||a)&&u&&(u.addTags(n??[]),u.addTags(a??[],!1)),(s||i)&&u&&(u.addMetadata(s??{}),u.addMetadata(i??{},!1)),u}}function De(r){return"name"in r?r:Se.fromMethods(r)}class Lr{getStore(){}run(e,t){return t()}enterWith(e){}}const $r=new Lr,zt=Symbol.for("lc:child_config");class Fr{getInstance(){return we()??$r}getRunnableConfig(){return this.getInstance().getStore()?.extra?.[zt]}runWithConfig(e,t,n){const a=j._configureSync(e?.callbacks,void 0,e?.tags,void 0,e?.metadata),s=this.getInstance(),i=s.getStore(),o=a?.getParentRunId(),u=a?.handlers?.find(c=>c?.name==="langchain_tracer");let l;return u&&o?l=u.getRunTreeWithTracingConfig(o):n||(l=new gt({name:"<runnable_lambda>",tracingEnabled:!1})),l&&(l.extra={...l.extra,[zt]:e}),i!==void 0&&i[Me]!==void 0&&(l===void 0&&(l={}),l[Me]=i[Me]),s.run(l,t)}initializeGlobalInstance(e){we()===void 0&&Sr(e)}}const q=new Fr,Xe=25;async function F(r){return j._configureSync(r?.callbacks,void 0,r?.tags,void 0,r?.metadata)}function Gt(...r){const e={};for(const t of r.filter(n=>!!n))for(const n of Object.keys(t))if(n==="metadata")e[n]={...e[n],...t[n]};else if(n==="tags"){const a=e[n]??[];e[n]=[...new Set(a.concat(t[n]??[]))]}else if(n==="configurable")e[n]={...e[n],...t[n]};else if(n==="timeout")e.timeout===void 0?e.timeout=t.timeout:t.timeout!==void 0&&(e.timeout=Math.min(e.timeout,t.timeout));else if(n==="signal")e.signal===void 0?e.signal=t.signal:t.signal!==void 0&&("any"in AbortSignal?e.signal=AbortSignal.any([e.signal,t.signal]):e.signal=t.signal);else if(n==="callbacks"){const a=e.callbacks,s=t.callbacks;if(Array.isArray(s))if(!a)e.callbacks=s;else if(Array.isArray(a))e.callbacks=a.concat(s);else{const i=a.copy();for(const o of s)i.addHandler(De(o),!0);e.callbacks=i}else if(s)if(!a)e.callbacks=s;else if(Array.isArray(a)){const i=s.copy();for(const o of a)i.addHandler(De(o),!0);e.callbacks=i}else e.callbacks=new j(s._parentRunId,{handlers:a.handlers.concat(s.handlers),inheritableHandlers:a.inheritableHandlers.concat(s.inheritableHandlers),tags:Array.from(new Set(a.tags.concat(s.tags))),inheritableTags:Array.from(new Set(a.inheritableTags.concat(s.inheritableTags))),metadata:{...a.metadata,...s.metadata}})}else{const a=n;e[a]=t[a]??e[a]}return e}const Dr=new Set(["string","number","boolean"]);function _(r){const e=q.getRunnableConfig();let t={tags:[],metadata:{},recursionLimit:25,runId:void 0};if(e){const{runId:n,runName:a,...s}=e;t=Object.entries(s).reduce((i,[o,u])=>(u!==void 0&&(i[o]=u),i),t)}if(r&&(t=Object.entries(r).reduce((n,[a,s])=>(s!==void 0&&(n[a]=s),n),t)),t?.configurable)for(const n of Object.keys(t.configurable))Dr.has(typeof t.configurable[n])&&!t.metadata?.[n]&&(t.metadata||(t.metadata={}),t.metadata[n]=t.configurable[n]);if(t.timeout!==void 0){if(t.timeout<=0)throw new Error("Timeout must be a positive number");const n=AbortSignal.timeout(t.timeout);t.signal!==void 0?"any"in AbortSignal&&(t.signal=AbortSignal.any([t.signal,n])):t.signal=n,delete t.timeout}return t}function I(r={},{callbacks:e,maxConcurrency:t,recursionLimit:n,runName:a,configurable:s,runId:i}={}){const o=_(r);return e!==void 0&&(delete o.runName,o.callbacks=e),n!==void 0&&(o.recursionLimit=n),t!==void 0&&(o.maxConcurrency=t),a!==void 0&&(o.runName=a),s!==void 0&&(o.configurable={...o.configurable,...s}),i!==void 0&&delete o.runId,o}function oe(r){return r?{configurable:r.configurable,recursionLimit:r.recursionLimit,callbacks:r.callbacks,tags:r.tags,metadata:r.metadata,maxConcurrency:r.maxConcurrency,timeout:r.timeout,signal:r.signal}:void 0}async function Z(r,e){if(e===void 0)return r;let t;return Promise.race([r.catch(n=>{if(!e?.aborted)throw n}),new Promise((n,a)=>{t=()=>{a(new Error("Aborted"))},e.addEventListener("abort",t),e.aborted&&a(new Error("Aborted"))})]).finally(()=>e.removeEventListener("abort",t))}class N extends ReadableStream{constructor(){super(...arguments),Object.defineProperty(this,"reader",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}ensureReader(){this.reader||(this.reader=this.getReader())}async next(){this.ensureReader();try{const e=await this.reader.read();return e.done?(this.reader.releaseLock(),{done:!0,value:void 0}):{done:!1,value:e.value}}catch(e){throw this.reader.releaseLock(),e}}async return(){if(this.ensureReader(),this.locked){const e=this.reader.cancel();this.reader.releaseLock(),await e}return{done:!0,value:void 0}}async throw(e){if(this.ensureReader(),this.locked){const t=this.reader.cancel();this.reader.releaseLock(),await t}throw e}[Symbol.asyncIterator](){return this}async[Symbol.asyncDispose](){await this.return()}static fromReadableStream(e){const t=e.getReader();return new N({start(n){return a();function a(){return t.read().then(({done:s,value:i})=>{if(s){n.close();return}return n.enqueue(i),a()})}},cancel(){t.releaseLock()}})}static fromAsyncGenerator(e){return new N({async pull(t){const{value:n,done:a}=await e.next();a&&t.close(),t.enqueue(n)},async cancel(t){await e.return(t)}})}}function gn(r,e=2){const t=Array.from({length:e},()=>[]);return t.map(async function*(a){for(;;)if(a.length===0){const s=await r.next();for(const i of t)i.push(s)}else{if(a[0].done)return;yield a.shift().value}})}function We(r,e){if(Array.isArray(r)&&Array.isArray(e))return r.concat(e);if(typeof r=="string"&&typeof e=="string")return r+e;if(typeof r=="number"&&typeof e=="number")return r+e;if("concat"in r&&typeof r.concat=="function")return r.concat(e);if(typeof r=="object"&&typeof e=="object"){const t={...r};for(const[n,a]of Object.entries(e))n in t&&!Array.isArray(t[n])?t[n]=We(t[n],a):t[n]=a;return t}else throw new Error(`Cannot concat ${typeof r} and ${typeof e}`)}class de{constructor(e){Object.defineProperty(this,"generator",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"setup",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"signal",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"firstResult",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"firstResultUsed",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.generator=e.generator,this.config=e.config,this.signal=e.signal??this.config?.signal,this.setup=new Promise((t,n)=>{q.runWithConfig(oe(e.config),async()=>{this.firstResult=e.generator.next(),e.startSetup?this.firstResult.then(e.startSetup).then(t,n):this.firstResult.then(a=>t(void 0),n)},!0)})}async next(...e){return this.signal?.throwIfAborted(),this.firstResultUsed?q.runWithConfig(oe(this.config),this.signal?async()=>Z(this.generator.next(...e),this.signal):async()=>this.generator.next(...e),!0):(this.firstResultUsed=!0,this.firstResult)}async return(e){return this.generator.return(e)}async throw(e){return this.generator.throw(e)}[Symbol.asyncIterator](){return this}async[Symbol.asyncDispose](){await this.return()}}async function Br(r,e,t,n,...a){const s=new de({generator:e,startSetup:t,signal:n}),i=await s.setup;return{output:r(s,i,...a),setup:i}}class K{constructor(e){Object.defineProperty(this,"ops",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.ops=e.ops??[]}concat(e){const t=this.ops.concat(e.ops),n=$e({},t);return new ve({ops:t,state:n[n.length-1].newDocument})}}class ve extends K{constructor(e){super(e),Object.defineProperty(this,"state",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.state=e.state}concat(e){const t=this.ops.concat(e.ops),n=$e(this.state,e.ops);return new ve({ops:t,state:n[n.length-1].newDocument})}static fromRunLogPatch(e){const t=$e({},e.ops);return new ve({ops:e.ops,state:t[t.length-1].newDocument})}}const Hr=r=>r.name==="log_stream_tracer";async function Wt(r,e){if(e==="original")throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");const{inputs:t}=r;if(["retriever","llm","prompt"].includes(r.run_type))return t;if(!(Object.keys(t).length===1&&t?.input===""))return t.input}async function Jt(r,e){const{outputs:t}=r;return e==="original"||["retriever","llm","prompt"].includes(r.run_type)?t:t!==void 0&&Object.keys(t).length===1&&t?.output!==void 0?t.output:t}function Ur(r){return r!==void 0&&r.message!==void 0}class Kt extends Ce{constructor(e){super({_awaitHandler:!0,...e}),Object.defineProperty(this,"autoClose",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"includeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_schemaFormat",{enumerable:!0,configurable:!0,writable:!0,value:"original"}),Object.defineProperty(this,"rootId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"keyMapByRunId",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"counterMapByRunName",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"transformStream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"writer",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"receiveStream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"log_stream_tracer"}),Object.defineProperty(this,"lc_prefer_streaming",{enumerable:!0,configurable:!0,writable:!0,value:!0}),this.autoClose=e?.autoClose??!0,this.includeNames=e?.includeNames,this.includeTypes=e?.includeTypes,this.includeTags=e?.includeTags,this.excludeNames=e?.excludeNames,this.excludeTypes=e?.excludeTypes,this.excludeTags=e?.excludeTags,this._schemaFormat=e?._schemaFormat??this._schemaFormat,this.transformStream=new TransformStream,this.writer=this.transformStream.writable.getWriter(),this.receiveStream=N.fromReadableStream(this.transformStream.readable)}[Symbol.asyncIterator](){return this.receiveStream}async persistRun(e){}_includeRun(e){if(e.id===this.rootId)return!1;const t=e.tags??[];let n=this.includeNames===void 0&&this.includeTags===void 0&&this.includeTypes===void 0;return this.includeNames!==void 0&&(n=n||this.includeNames.includes(e.name)),this.includeTypes!==void 0&&(n=n||this.includeTypes.includes(e.run_type)),this.includeTags!==void 0&&(n=n||t.find(a=>this.includeTags?.includes(a))!==void 0),this.excludeNames!==void 0&&(n=n&&!this.excludeNames.includes(e.name)),this.excludeTypes!==void 0&&(n=n&&!this.excludeTypes.includes(e.run_type)),this.excludeTags!==void 0&&(n=n&&t.every(a=>!this.excludeTags?.includes(a))),n}async*tapOutputIterable(e,t){for await(const n of t){if(e!==this.rootId){const a=this.keyMapByRunId[e];a&&await this.writer.write(new K({ops:[{op:"add",path:`/logs/${a}/streamed_output/-`,value:n}]}))}yield n}}async onRunCreate(e){if(this.rootId===void 0&&(this.rootId=e.id,await this.writer.write(new K({ops:[{op:"replace",path:"",value:{id:e.id,name:e.name,type:e.run_type,streamed_output:[],final_output:void 0,logs:{}}}]}))),!this._includeRun(e))return;this.counterMapByRunName[e.name]===void 0&&(this.counterMapByRunName[e.name]=0),this.counterMapByRunName[e.name]+=1;const t=this.counterMapByRunName[e.name];this.keyMapByRunId[e.id]=t===1?e.name:`${e.name}:${t}`;const n={id:e.id,name:e.name,type:e.run_type,tags:e.tags??[],metadata:e.extra?.metadata??{},start_time:new Date(e.start_time).toISOString(),streamed_output:[],streamed_output_str:[],final_output:void 0,end_time:void 0};this._schemaFormat==="streaming_events"&&(n.inputs=await Wt(e,this._schemaFormat)),await this.writer.write(new K({ops:[{op:"add",path:`/logs/${this.keyMapByRunId[e.id]}`,value:n}]}))}async onRunUpdate(e){try{const t=this.keyMapByRunId[e.id];if(t===void 0)return;const n=[];this._schemaFormat==="streaming_events"&&n.push({op:"replace",path:`/logs/${t}/inputs`,value:await Wt(e,this._schemaFormat)}),n.push({op:"add",path:`/logs/${t}/final_output`,value:await Jt(e,this._schemaFormat)}),e.end_time!==void 0&&n.push({op:"add",path:`/logs/${t}/end_time`,value:new Date(e.end_time).toISOString()});const a=new K({ops:n});await this.writer.write(a)}finally{if(e.id===this.rootId){const t=new K({ops:[{op:"replace",path:"/final_output",value:await Jt(e,this._schemaFormat)}]});await this.writer.write(t),this.autoClose&&await this.writer.close()}}}async onLLMNewToken(e,t,n){const a=this.keyMapByRunId[e.id];if(a===void 0)return;const s=e.inputs.messages!==void 0;let i;s?Ur(n?.chunk)?i=n?.chunk:i=new ce({id:`run-${e.id}`,content:t}):i=t;const o=new K({ops:[{op:"add",path:`/logs/${a}/streamed_output_str/-`,value:t},{op:"add",path:`/logs/${a}/streamed_output/-`,value:i}]});await this.writer.write(o)}}const Vt="__run";class ue{constructor(e){Object.defineProperty(this,"text",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"generationInfo",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.text=e.text,this.generationInfo=e.generationInfo}concat(e){return new ue({text:this.text+e.text,generationInfo:{...this.generationInfo,...e.generationInfo}})}}class Oe extends ue{constructor(e){super(e),Object.defineProperty(this,"message",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.message=e.message}concat(e){return new Oe({text:this.text+e.text,generationInfo:{...this.generationInfo,...e.generationInfo},message:this.message.concat(e.message)})}}function Re({name:r,serialized:e}){return r!==void 0?r:e?.name!==void 0?e.name:e?.id!==void 0&&Array.isArray(e?.id)?e.id[e.id.length-1]:"Unnamed"}const zr=r=>r.name==="event_stream_tracer";class Gr extends Ce{constructor(e){super({_awaitHandler:!0,...e}),Object.defineProperty(this,"autoClose",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"includeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"runInfoMap",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),Object.defineProperty(this,"tappedPromises",{enumerable:!0,configurable:!0,writable:!0,value:new Map}),Object.defineProperty(this,"transformStream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"writer",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"receiveStream",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"event_stream_tracer"}),Object.defineProperty(this,"lc_prefer_streaming",{enumerable:!0,configurable:!0,writable:!0,value:!0}),this.autoClose=e?.autoClose??!0,this.includeNames=e?.includeNames,this.includeTypes=e?.includeTypes,this.includeTags=e?.includeTags,this.excludeNames=e?.excludeNames,this.excludeTypes=e?.excludeTypes,this.excludeTags=e?.excludeTags,this.transformStream=new TransformStream,this.writer=this.transformStream.writable.getWriter(),this.receiveStream=N.fromReadableStream(this.transformStream.readable)}[Symbol.asyncIterator](){return this.receiveStream}async persistRun(e){}_includeRun(e){const t=e.tags??[];let n=this.includeNames===void 0&&this.includeTags===void 0&&this.includeTypes===void 0;return this.includeNames!==void 0&&(n=n||this.includeNames.includes(e.name)),this.includeTypes!==void 0&&(n=n||this.includeTypes.includes(e.runType)),this.includeTags!==void 0&&(n=n||t.find(a=>this.includeTags?.includes(a))!==void 0),this.excludeNames!==void 0&&(n=n&&!this.excludeNames.includes(e.name)),this.excludeTypes!==void 0&&(n=n&&!this.excludeTypes.includes(e.runType)),this.excludeTags!==void 0&&(n=n&&t.every(a=>!this.excludeTags?.includes(a))),n}async*tapOutputIterable(e,t){const n=await t.next();if(n.done)return;const a=this.runInfoMap.get(e);if(a===void 0){yield n.value;return}function s(o,u){return o==="llm"&&typeof u=="string"?new ue({text:u}):u}let i=this.tappedPromises.get(e);if(i===void 0){let o;i=new Promise(u=>{o=u}),this.tappedPromises.set(e,i);try{const u={event:`on_${a.runType}_stream`,run_id:e,name:a.name,tags:a.tags,metadata:a.metadata,data:{}};await this.send({...u,data:{chunk:s(a.runType,n.value)}},a),yield n.value;for await(const l of t)a.runType!=="tool"&&a.runType!=="retriever"&&await this.send({...u,data:{chunk:s(a.runType,l)}},a),yield l}finally{o()}}else{yield n.value;for await(const o of t)yield o}}async send(e,t){this._includeRun(t)&&await this.writer.write(e)}async sendEndEvent(e,t){const n=this.tappedPromises.get(e.run_id);n!==void 0?n.then(()=>{this.send(e,t)}):await this.send(e,t)}async onLLMStart(e){const t=Re(e),n=e.inputs.messages!==void 0?"chat_model":"llm",a={tags:e.tags??[],metadata:e.extra?.metadata??{},name:t,runType:n,inputs:e.inputs};this.runInfoMap.set(e.id,a);const s=`on_${n}_start`;await this.send({event:s,data:{input:e.inputs},name:t,tags:e.tags??[],run_id:e.id,metadata:e.extra?.metadata??{}},a)}async onLLMNewToken(e,t,n){const a=this.runInfoMap.get(e.id);let s,i;if(a===void 0)throw new Error(`onLLMNewToken: Run ID ${e.id} not found in run map.`);if(this.runInfoMap.size!==1){if(a.runType==="chat_model")i="on_chat_model_stream",n?.chunk===void 0?s=new ce({content:t,id:`run-${e.id}`}):s=n.chunk.message;else if(a.runType==="llm")i="on_llm_stream",n?.chunk===void 0?s=new ue({text:t}):s=n.chunk;else throw new Error(`Unexpected run type ${a.runType}`);await this.send({event:i,data:{chunk:s},run_id:e.id,name:a.name,tags:a.tags,metadata:a.metadata},a)}}async onLLMEnd(e){const t=this.runInfoMap.get(e.id);this.runInfoMap.delete(e.id);let n;if(t===void 0)throw new Error(`onLLMEnd: Run ID ${e.id} not found in run map.`);const a=e.outputs?.generations;let s;if(t.runType==="chat_model"){for(const i of a??[]){if(s!==void 0)break;s=i[0]?.message}n="on_chat_model_end"}else if(t.runType==="llm")s={generations:a?.map(i=>i.map(o=>({text:o.text,generationInfo:o.generationInfo}))),llmOutput:e.outputs?.llmOutput??{}},n="on_llm_end";else throw new Error(`onLLMEnd: Unexpected run type: ${t.runType}`);await this.sendEndEvent({event:n,data:{output:s,input:t.inputs},run_id:e.id,name:t.name,tags:t.tags,metadata:t.metadata},t)}async onChainStart(e){const t=Re(e),n=e.run_type??"chain",a={tags:e.tags??[],metadata:e.extra?.metadata??{},name:t,runType:e.run_type};let s={};e.inputs.input===""&&Object.keys(e.inputs).length===1?(s={},a.inputs={}):e.inputs.input!==void 0?(s.input=e.inputs.input,a.inputs=e.inputs.input):(s.input=e.inputs,a.inputs=e.inputs),this.runInfoMap.set(e.id,a),await this.send({event:`on_${n}_start`,data:s,name:t,tags:e.tags??[],run_id:e.id,metadata:e.extra?.metadata??{}},a)}async onChainEnd(e){const t=this.runInfoMap.get(e.id);if(this.runInfoMap.delete(e.id),t===void 0)throw new Error(`onChainEnd: Run ID ${e.id} not found in run map.`);const n=`on_${e.run_type}_end`,a=e.inputs??t.inputs??{},i={output:e.outputs?.output??e.outputs,input:a};a.input&&Object.keys(a).length===1&&(i.input=a.input,t.inputs=a.input),await this.sendEndEvent({event:n,data:i,run_id:e.id,name:t.name,tags:t.tags,metadata:t.metadata??{}},t)}async onToolStart(e){const t=Re(e),n={tags:e.tags??[],metadata:e.extra?.metadata??{},name:t,runType:"tool",inputs:e.inputs??{}};this.runInfoMap.set(e.id,n),await this.send({event:"on_tool_start",data:{input:e.inputs??{}},name:t,run_id:e.id,tags:e.tags??[],metadata:e.extra?.metadata??{}},n)}async onToolEnd(e){const t=this.runInfoMap.get(e.id);if(this.runInfoMap.delete(e.id),t===void 0)throw new Error(`onToolEnd: Run ID ${e.id} not found in run map.`);if(t.inputs===void 0)throw new Error(`onToolEnd: Run ID ${e.id} is a tool call, and is expected to have traced inputs.`);const n=e.outputs?.output===void 0?e.outputs:e.outputs.output;await this.sendEndEvent({event:"on_tool_end",data:{output:n,input:t.inputs},run_id:e.id,name:t.name,tags:t.tags,metadata:t.metadata},t)}async onRetrieverStart(e){const t=Re(e),a={tags:e.tags??[],metadata:e.extra?.metadata??{},name:t,runType:"retriever",inputs:{query:e.inputs.query}};this.runInfoMap.set(e.id,a),await this.send({event:"on_retriever_start",data:{input:{query:e.inputs.query}},name:t,tags:e.tags??[],run_id:e.id,metadata:e.extra?.metadata??{}},a)}async onRetrieverEnd(e){const t=this.runInfoMap.get(e.id);if(this.runInfoMap.delete(e.id),t===void 0)throw new Error(`onRetrieverEnd: Run ID ${e.id} not found in run map.`);await this.sendEndEvent({event:"on_retriever_end",data:{output:e.outputs?.documents??e.outputs,input:t.inputs},run_id:e.id,name:t.name,tags:t.tags,metadata:t.metadata},t)}async handleCustomEvent(e,t,n){const a=this.runInfoMap.get(n);if(a===void 0)throw new Error(`handleCustomEvent: Run ID ${n} not found in run map.`);await this.send({event:"on_custom_event",run_id:n,name:e,tags:a.tags,metadata:a.metadata,data:t},a)}async finish(){const e=[...this.tappedPromises.values()];Promise.all(e).finally(()=>{this.writer.close()})}}const Wr=[400,401,402,403,404,405,406,407,409],Jr=r=>{if(r.message.startsWith("Cancel")||r.message.startsWith("AbortError")||r.name==="AbortError"||r?.code==="ECONNABORTED")throw r;const e=r?.response?.status??r?.status;if(e&&Wr.includes(+e))throw r;if(r?.error?.code==="insufficient_quota"){const t=new Error(r?.message);throw t.name="InsufficientQuotaError",t}};class Et{constructor(e){Object.defineProperty(this,"maxConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxRetries",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"onFailedAttempt",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxConcurrency=e.maxConcurrency??1/0,this.maxRetries=e.maxRetries??6,this.onFailedAttempt=e.onFailedAttempt??Jr;const t="default"in ie?ie.default:ie;this.queue=new t({concurrency:this.maxConcurrency})}call(e,...t){return this.queue.add(()=>rt(()=>e(...t).catch(n=>{throw n instanceof Error?n:new Error(n)}),{onFailedAttempt:this.onFailedAttempt,retries:this.maxRetries,randomize:!0}),{throwOnTimeout:!0})}callWithOptions(e,t,...n){return e.signal?Promise.race([this.call(t,...n),new Promise((a,s)=>{e.signal?.addEventListener("abort",()=>{s(new Error("AbortError"))})})]):this.call(t,...n)}fetch(...e){return this.call(()=>fetch(...e).then(t=>t.ok?t:Promise.reject(t)))}}class bn extends Ce{constructor({config:e,onStart:t,onEnd:n,onError:a}){super({_awaitHandler:!0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"RootListenersTracer"}),Object.defineProperty(this,"rootId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"argOnStart",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"argOnEnd",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"argOnError",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.config=e,this.argOnStart=t,this.argOnEnd=n,this.argOnError=a}persistRun(e){return Promise.resolve()}async onRunCreate(e){this.rootId||(this.rootId=e.id,this.argOnStart&&await this.argOnStart(e,this.config))}async onRunUpdate(e){e.id===this.rootId&&(e.error?this.argOnError&&await this.argOnError(e,this.config):this.argOnEnd&&await this.argOnEnd(e,this.config))}}function St(r){return r?r.lc_runnable:!1}class Kr{constructor(e){Object.defineProperty(this,"includeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"includeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeNames",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTypes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"excludeTags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.includeNames=e.includeNames,this.includeTypes=e.includeTypes,this.includeTags=e.includeTags,this.excludeNames=e.excludeNames,this.excludeTypes=e.excludeTypes,this.excludeTags=e.excludeTags}includeEvent(e,t){let n=this.includeNames===void 0&&this.includeTypes===void 0&&this.includeTags===void 0;const a=e.tags??[];return this.includeNames!==void 0&&(n=n||this.includeNames.includes(e.name)),this.includeTypes!==void 0&&(n=n||this.includeTypes.includes(t)),this.includeTags!==void 0&&(n=n||a.some(s=>this.includeTags?.includes(s))),this.excludeNames!==void 0&&(n=n&&!this.excludeNames.includes(e.name)),this.excludeTypes!==void 0&&(n=n&&!this.excludeTypes.includes(t)),this.excludeTags!==void 0&&(n=n&&a.every(s=>!this.excludeTags?.includes(s))),n}}function et(r){return r.replace(/[^a-zA-Z-_0-9]/g,"_")}const Vr=["*","_","`"];function qr(r){let e="";for(const[t,n]of Object.entries(r))e+=`	classDef ${t} ${n};
`;return e}function Zr(r,e,t){const{firstNode:n,lastNode:a,nodeColors:s,withStyles:i=!0,curveStyle:o="linear",wrapLabelNWords:u=9}=t??{};let l=i?`%%{init: {'flowchart': {'curve': '${o}'}}}%%
graph TD;
`:`graph TD;
`;if(i){const h="default",p={[h]:"{0}({1})"};n!==void 0&&(p[n]="{0}([{1}]):::first"),a!==void 0&&(p[a]="{0}([{1}]):::last");for(const[m,g]of Object.entries(r)){const b=g.name.split(":").pop()??"";let v=Vr.some(O=>b.startsWith(O)&&b.endsWith(O))?`<p>${b}</p>`:b;Object.keys(g.metadata??{}).length&&(v+=`<hr/><small><em>${Object.entries(g.metadata??{}).map(([O,U])=>`${O} = ${U}`).join(`
`)}</em></small>`);const k=(p[m]??p[h]).replace("{0}",et(m)).replace("{1}",v);l+=`	${k}
`}}const c={};for(const h of e){const p=h.source.split(":"),m=h.target.split(":"),g=p.filter((b,w)=>b===m[w]).join(":");c[g]||(c[g]=[]),c[g].push(h)}const f=new Set;function d(h,p){const m=h.length===1&&h[0].source===h[0].target;if(p&&!m){const g=p.split(":").pop();if(f.has(g))throw new Error(`Found duplicate subgraph '${g}' -- this likely means that you're reusing a subgraph node with the same name. Please adjust your graph to have subgraph nodes with unique names.`);f.add(g),l+=`	subgraph ${g}
`}for(const g of h){const{source:b,target:w,data:v,conditional:k}=g;let O="";if(v!==void 0){let U=v;const Ke=U.split(" ");Ke.length>u&&(U=Array.from({length:Math.ceil(Ke.length/u)},(Ya,It)=>Ke.slice(It*u,(It+1)*u).join(" ")).join("&nbsp;<br>&nbsp;")),O=k?` -. &nbsp;${U}&nbsp; .-> `:` -- &nbsp;${U}&nbsp; --> `}else O=k?" -.-> ":" --> ";l+=`	${et(b)}${O}${et(w)};
`}for(const g in c)g.startsWith(`${p}:`)&&g!==p&&d(c[g],g);p&&!m&&(l+=`	end
`)}d(c[""]??[],"");for(const h in c)!h.includes(":")&&h!==""&&d(c[h],h);return i&&(l+=qr(s??{})),l}async function Yr(r,e){let{backgroundColor:t="white"}=e??{};const n=btoa(r);t!==void 0&&(/^#(?:[0-9a-fA-F]{3}){1,2}$/.test(t)||(t=`!${t}`));const a=`https://mermaid.ink/img/${n}?bgColor=${t}`,s=await fetch(a);if(!s.ok)throw new Error(["Failed to render the graph using the Mermaid.INK API.",`Status code: ${s.status}`,`Status text: ${s.statusText}`].join(`
`));return await s.blob()}function H(r){if(typeof r!="object"||r===null)return!1;const e=r;if(!("_zod"in e))return!1;const t=e._zod;return typeof t=="object"&&t!==null&&"def"in t}function W(r){if(typeof r!="object"||r===null)return!1;const e=r;if(!("_def"in e)||"_zod"in e)return!1;const t=e._def;return typeof t=="object"&&t!=null&&"typeName"in t}function Pe(r){return!r||typeof r!="object"||Array.isArray(r)?!1:!!(H(r)||W(r))}async function Qr(r,e){if(H(r))try{return{success:!0,data:await jn(r,e)}}catch(t){return{success:!1,error:t}}if(W(r))return r.safeParse(e);throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType")}async function Xr(r,e){if(H(r))return Ln(r,e);if(W(r))return r.parse(e);throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType")}function yn(r){if(H(r))return Y.get(r)?.description;if(W(r)||"description"in r&&typeof r.description=="string")return r.description}function ea(r){return Pe(r)?W(r)?r._def.typeName==="ZodString":H(r)?r._zod.def.type==="string":!1:!1}function _e(r){return H(r)?typeof r=="object"&&r!==null&&"_zod"in r&&typeof r._zod=="object"&&r._zod!==null&&"def"in r._zod&&typeof r._zod.def=="object"&&r._zod.def!==null&&"type"in r._zod.def&&r._zod.def.type==="object":!1}function _n(r){return H(r)?typeof r=="object"&&r!==null&&"_zod"in r&&typeof r._zod=="object"&&r._zod!==null&&"def"in r._zod&&typeof r._zod.def=="object"&&r._zod.def!==null&&"type"in r._zod.def&&r._zod.def.type==="array":!1}function ft(r,e=!1){if(W(r))return r.strict();if(_e(r)){const t=r._zod.def.shape;if(e)for(const[s,i]of Object.entries(r._zod.def.shape)){if(_e(i)){const u=ft(i,e);t[s]=u}else if(_n(i)){let u=i._zod.def.element;_e(u)&&(u=ft(u,e)),t[s]=Le(i,{...i._zod.def,element:u})}else t[s]=i;const o=Y.get(i);o&&Y.add(t[s],o)}const n=Le(r,{...r._zod.def,shape:t,catchall:Nn(Mn)}),a=Y.get(r);return a&&Y.add(n,a),n}throw new Error("Schema must be an instance of z3.ZodObject or z4.$ZodObject")}function ta(r){return W(r)&&"typeName"in r._def&&r._def.typeName==="ZodEffects"}function na(r){return H(r)&&r._zod.def.type==="pipe"}function me(r,e=!1){if(W(r))return ta(r)?me(r._def.schema,e):r;if(H(r)){let t=r;if(na(r)&&(t=me(r._zod.def.in,e)),e){if(_e(t)){const a=t._zod.def.shape;for(const[s,i]of Object.entries(t._zod.def.shape))a[s]=me(i,e);t=Le(t,{...t._zod.def,shape:a})}else if(_n(t)){const a=me(t._zod.def.element,e);t=Le(t,{...t._zod.def,element:a})}}const n=Y.get(r);return n&&Y.add(t,n),t}throw new Error("Schema must be an instance of z3.ZodType or z4.$ZodType")}function Ct(r){if(H(r)){const e=me(r,!0);if(_e(e)){const t=ft(e,!0);return Rt(t)}else return Rt(r)}return W(r)?$n(r):r}function ra(r,e){if(r!==void 0&&!je(r))return r;if(St(e))try{let t=e.getName();return t=t.startsWith("Runnable")?t.slice(8):t,t}catch{return e.getName()}else return e.name??"UnknownSchema"}function aa(r){return St(r.data)?{type:"runnable",data:{id:r.data.lc_id,name:r.data.getName()}}:{type:"schema",data:{...Ct(r.data.schema),title:r.data.name}}}class Je{constructor(e){Object.defineProperty(this,"nodes",{enumerable:!0,configurable:!0,writable:!0,value:{}}),Object.defineProperty(this,"edges",{enumerable:!0,configurable:!0,writable:!0,value:[]}),this.nodes=e?.nodes??this.nodes,this.edges=e?.edges??this.edges}toJSON(){const e={};return Object.values(this.nodes).forEach((t,n)=>{e[t.id]=je(t.id)?n:t.id}),{nodes:Object.values(this.nodes).map(t=>({id:e[t.id],...aa(t)})),edges:this.edges.map(t=>{const n={source:e[t.source],target:e[t.target]};return typeof t.data<"u"&&(n.data=t.data),typeof t.conditional<"u"&&(n.conditional=t.conditional),n})}}addNode(e,t,n){if(t!==void 0&&this.nodes[t]!==void 0)throw new Error(`Node with id ${t} already exists`);const a=t??z(),s={id:a,data:e,name:ra(t,e),metadata:n};return this.nodes[a]=s,s}removeNode(e){delete this.nodes[e.id],this.edges=this.edges.filter(t=>t.source!==e.id&&t.target!==e.id)}addEdge(e,t,n,a){if(this.nodes[e.id]===void 0)throw new Error(`Source node ${e.id} not in graph`);if(this.nodes[t.id]===void 0)throw new Error(`Target node ${t.id} not in graph`);const s={source:e.id,target:t.id,data:n,conditional:a};return this.edges.push(s),s}firstNode(){return qt(this)}lastNode(){return Zt(this)}extend(e,t=""){let n=t;Object.values(e.nodes).map(l=>l.id).every(je)&&(n="");const s=l=>n?`${n}:${l}`:l;Object.entries(e.nodes).forEach(([l,c])=>{this.nodes[s(l)]={...c,id:s(l)}});const i=e.edges.map(l=>({...l,source:s(l.source),target:s(l.target)}));this.edges=[...this.edges,...i];const o=e.firstNode(),u=e.lastNode();return[o?{id:s(o.id),data:o.data}:void 0,u?{id:s(u.id),data:u.data}:void 0]}trimFirstNode(){const e=this.firstNode();e&&qt(this,[e.id])&&this.removeNode(e)}trimLastNode(){const e=this.lastNode();e&&Zt(this,[e.id])&&this.removeNode(e)}reid(){const e=Object.fromEntries(Object.values(this.nodes).map(a=>[a.id,a.name])),t=new Map;Object.values(e).forEach(a=>{t.set(a,(t.get(a)||0)+1)});const n=a=>{const s=e[a];return je(a)&&t.get(s)===1?s:a};return new Je({nodes:Object.fromEntries(Object.entries(this.nodes).map(([a,s])=>[n(a),{...s,id:n(a)}])),edges:this.edges.map(a=>({...a,source:n(a.source),target:n(a.target)}))})}drawMermaid(e){const{withStyles:t,curveStyle:n,nodeColors:a={default:"fill:#f2f0ff,line-height:1.2",first:"fill-opacity:0",last:"fill:#bfb6fc"},wrapLabelNWords:s}=e??{},i=this.reid(),o=i.firstNode(),u=i.lastNode();return Zr(i.nodes,i.edges,{firstNode:o?.id,lastNode:u?.id,withStyles:t,curveStyle:n,nodeColors:a,wrapLabelNWords:s})}async drawMermaidPng(e){const t=this.drawMermaid(e);return Yr(t,{backgroundColor:e?.backgroundColor})}}function qt(r,e=[]){const t=new Set(r.edges.filter(a=>!e.includes(a.source)).map(a=>a.target)),n=[];for(const a of Object.values(r.nodes))!e.includes(a.id)&&!t.has(a.id)&&n.push(a);return n.length===1?n[0]:void 0}function Zt(r,e=[]){const t=new Set(r.edges.filter(a=>!e.includes(a.target)).map(a=>a.source)),n=[];for(const a of Object.values(r.nodes))!e.includes(a.id)&&!t.has(a.id)&&n.push(a);return n.length===1?n[0]:void 0}function ia(r){const e=new TextEncoder,t=new ReadableStream({async start(n){for await(const a of r)n.enqueue(e.encode(`event: data
data: ${JSON.stringify(a)}

`));n.enqueue(e.encode(`event: end

`)),n.close()}});return N.fromReadableStream(t)}function Yt(r){return typeof r=="object"&&r!==null&&typeof r[Symbol.iterator]=="function"&&typeof r.next=="function"}const sa=r=>r!=null&&typeof r=="object"&&"next"in r&&typeof r.next=="function";function ht(r){return typeof r=="object"&&r!==null&&typeof r[Symbol.asyncIterator]=="function"}function*Qt(r,e){for(;;){const{value:t,done:n}=q.runWithConfig(oe(r),e.next.bind(e),!0);if(n)break;yield t}}async function*pt(r,e){const t=e[Symbol.asyncIterator]();for(;;){const{value:n,done:a}=await q.runWithConfig(oe(r),t.next.bind(e),!0);if(a)break;yield n}}function C(r,e){return r&&!Array.isArray(r)&&!(r instanceof Date)&&typeof r=="object"?r:{[e]:r}}class P extends te{constructor(){super(...arguments),Object.defineProperty(this,"lc_runnable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}getName(e){const t=this.name??this.constructor.lc_name()??this.constructor.name;return e?`${t}${e}`:t}bind(e){return new ee({bound:this,kwargs:e,config:{}})}map(){return new Be({bound:this})}withRetry(e){return new wn({bound:this,kwargs:{},config:{},maxAttemptNumber:e?.stopAfterAttempt,...e})}withConfig(e){return new ee({bound:this,config:e,kwargs:{}})}withFallbacks(e){const t=Array.isArray(e)?e:e.fallbacks;return new ua({runnable:this,fallbacks:t})}_getOptionsList(e,t=0){if(Array.isArray(e)&&e.length!==t)throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${e.length} options for ${t} inputs`);if(Array.isArray(e))return e.map(_);if(t>1&&!Array.isArray(e)&&e.runId){console.warn("Provided runId will be used only for the first element of the batch.");const n=Object.fromEntries(Object.entries(e).filter(([a])=>a!=="runId"));return Array.from({length:t},(a,s)=>_(s===0?e:n))}return Array.from({length:t},()=>_(e))}async batch(e,t,n){const a=this._getOptionsList(t??{},e.length),s=a[0]?.maxConcurrency??n?.maxConcurrency,i=new Et({maxConcurrency:s,onFailedAttempt:u=>{throw u}}),o=e.map((u,l)=>i.call(async()=>{try{return await this.invoke(u,a[l])}catch(c){if(n?.returnExceptions)return c;throw c}}));return Promise.all(o)}async*_streamIterator(e,t){yield this.invoke(e,t)}async stream(e,t){const n=_(t),a=new de({generator:this._streamIterator(e,n),config:n});return await a.setup,N.fromAsyncGenerator(a)}_separateRunnableConfigFromCallOptions(e){let t;e===void 0?t=_(e):t=_({callbacks:e.callbacks,tags:e.tags,metadata:e.metadata,runName:e.runName,configurable:e.configurable,recursionLimit:e.recursionLimit,maxConcurrency:e.maxConcurrency,runId:e.runId,timeout:e.timeout,signal:e.signal});const n={...e};return delete n.callbacks,delete n.tags,delete n.metadata,delete n.runName,delete n.configurable,delete n.recursionLimit,delete n.maxConcurrency,delete n.runId,delete n.timeout,delete n.signal,[t,n]}async _callWithConfig(e,t,n){const a=_(n),i=await(await F(a))?.handleChainStart(this.toJSON(),C(t,"input"),a.runId,a?.runType,void 0,void 0,a?.runName??this.getName());delete a.runId;let o;try{const u=e.call(this,t,a,i);o=await Z(u,n?.signal)}catch(u){throw await i?.handleChainError(u),u}return await i?.handleChainEnd(C(o,"output")),o}async _batchWithConfig(e,t,n,a){const s=this._getOptionsList(n??{},t.length),i=await Promise.all(s.map(F)),o=await Promise.all(i.map(async(l,c)=>{const f=await l?.handleChainStart(this.toJSON(),C(t[c],"input"),s[c].runId,s[c].runType,void 0,void 0,s[c].runName??this.getName());return delete s[c].runId,f}));let u;try{const l=e.call(this,t,s,o,a);u=await Z(l,s?.[0]?.signal)}catch(l){throw await Promise.all(o.map(c=>c?.handleChainError(l))),l}return await Promise.all(o.map(l=>l?.handleChainEnd(C(u,"output")))),u}_concatOutputChunks(e,t){return We(e,t)}async*_transformStreamWithConfig(e,t,n){let a,s=!0,i,o=!0;const u=_(n),l=await F(u),c=this;async function*f(){for await(const h of e){if(s)if(a===void 0)a=h;else try{a=c._concatOutputChunks(a,h)}catch{a=void 0,s=!1}yield h}}let d;try{const h=await Br(t.bind(this),f(),async()=>l?.handleChainStart(this.toJSON(),{input:""},u.runId,u.runType,void 0,void 0,u.runName??this.getName()),n?.signal,u);delete u.runId,d=h.setup;const p=d?.handlers.find(zr);let m=h.output;p!==void 0&&d!==void 0&&(m=p.tapOutputIterable(d.runId,m));const g=d?.handlers.find(Hr);g!==void 0&&d!==void 0&&(m=g.tapOutputIterable(d.runId,m));for await(const b of m)if(yield b,o)if(i===void 0)i=b;else try{i=this._concatOutputChunks(i,b)}catch{i=void 0,o=!1}}catch(h){throw await d?.handleChainError(h,void 0,void 0,void 0,{inputs:C(a,"input")}),h}await d?.handleChainEnd(i??{},void 0,void 0,void 0,{inputs:C(a,"input")})}getGraph(e){const t=new Je,n=t.addNode({name:`${this.getName()}Input`,schema:At()}),a=t.addNode(this),s=t.addNode({name:`${this.getName()}Output`,schema:At()});return t.addEdge(n,a),t.addEdge(a,s),t}pipe(e){return new G({first:this,last:Q(e)})}pick(e){return this.pipe(new la(e))}assign(e){return this.pipe(new vn(new fe({steps:e})))}async*transform(e,t){let n;for await(const a of e)n===void 0?n=a:n=this._concatOutputChunks(n,a);yield*this._streamIterator(n,_(t))}async*streamLog(e,t,n){const a=new Kt({...n,autoClose:!1,_schemaFormat:"original"}),s=_(t);yield*this._streamLog(e,a,s)}async*_streamLog(e,t,n){const{callbacks:a}=n;if(a===void 0)n.callbacks=[t];else if(Array.isArray(a))n.callbacks=a.concat([t]);else{const u=a.copy();u.addHandler(t,!0),n.callbacks=u}const s=this.stream(e,n);async function i(){try{const u=await s;for await(const l of u){const c=new K({ops:[{op:"add",path:"/streamed_output/-",value:l}]});await t.writer.write(c)}}finally{await t.writer.close()}}const o=i();try{for await(const u of t)yield u}finally{await o}}streamEvents(e,t,n){let a;if(t.version==="v1")a=this._streamEventsV1(e,t,n);else if(t.version==="v2")a=this._streamEventsV2(e,t,n);else throw new Error('Only versions "v1" and "v2" of the schema are currently supported.');return t.encoding==="text/event-stream"?ia(a):N.fromAsyncGenerator(a)}async*_streamEventsV2(e,t,n){const a=new Gr({...n,autoClose:!1}),s=_(t),i=s.runId??z();s.runId=i;const o=s.callbacks;if(o===void 0)s.callbacks=[a];else if(Array.isArray(o))s.callbacks=o.concat(a);else{const p=o.copy();p.addHandler(a,!0),s.callbacks=p}const u=new AbortController,l=this;async function c(){let p,m=null;try{t?.signal?"any"in AbortSignal?p=AbortSignal.any([u.signal,t.signal]):(p=t.signal,m=()=>{u.abort()},t.signal.addEventListener("abort",m,{once:!0})):p=u.signal;const g=await l.stream(e,{...s,signal:p}),b=a.tapOutputIterable(i,g);for await(const w of b)if(u.signal.aborted)break}finally{await a.finish(),p&&m&&p.removeEventListener("abort",m)}}const f=c();let d=!1,h;try{for await(const p of a){if(!d){p.data.input=e,d=!0,h=p.run_id,yield p;continue}p.run_id===h&&p.event.endsWith("_end")&&p.data?.input&&delete p.data.input,yield p}}finally{u.abort(),await f}}async*_streamEventsV1(e,t,n){let a,s=!1;const i=_(t),o=i.tags??[],u=i.metadata??{},l=i.runName??this.getName(),c=new Kt({...n,autoClose:!1,_schemaFormat:"streaming_events"}),f=new Kr({...n}),d=this._streamLog(e,c,i);for await(const p of d){if(a?a=a.concat(p):a=ve.fromRunLogPatch(p),a.state===void 0)throw new Error('Internal error: "streamEvents" state is missing. Please open a bug report.');if(!s){s=!0;const w={...a.state},v={run_id:w.id,event:`on_${w.type}_start`,name:l,tags:o,metadata:u,data:{input:e}};f.includeEvent(v,w.type)&&(yield v)}const m=p.ops.filter(w=>w.path.startsWith("/logs/")).map(w=>w.path.split("/")[2]),g=[...new Set(m)];for(const w of g){let v,k={};const O=a.state.logs[w];if(O.end_time===void 0?O.streamed_output.length>0?v="stream":v="start":v="end",v==="start")O.inputs!==void 0&&(k.input=O.inputs);else if(v==="end")O.inputs!==void 0&&(k.input=O.inputs),k.output=O.final_output;else if(v==="stream"){const U=O.streamed_output.length;if(U!==1)throw new Error(`Expected exactly one chunk of streamed output, got ${U} instead. Encountered in: "${O.name}"`);k={chunk:O.streamed_output[0]},O.streamed_output=[]}yield{event:`on_${O.type}_${v}`,name:O.name,run_id:O.id,tags:O.tags,metadata:O.metadata,data:k}}const{state:b}=a;if(b.streamed_output.length>0){const w=b.streamed_output.length;if(w!==1)throw new Error(`Expected exactly one chunk of streamed output, got ${w} instead. Encountered in: "${b.name}"`);const v={chunk:b.streamed_output[0]};b.streamed_output=[];const k={event:`on_${b.type}_stream`,run_id:b.id,tags:o,metadata:u,name:l,data:v};f.includeEvent(k,b.type)&&(yield k)}}const h=a?.state;if(h!==void 0){const p={event:`on_${h.type}_end`,name:l,run_id:h.id,tags:o,metadata:u,data:{output:h.final_output}};f.includeEvent(p,h.type)&&(yield p)}}static isRunnable(e){return St(e)}withListeners({onStart:e,onEnd:t,onError:n}){return new ee({bound:this,config:{},configFactories:[a=>({callbacks:[new bn({config:a,onStart:e,onEnd:t,onError:n})]})]})}asTool(e){return ca(this,e)}}class ee extends P{static lc_name(){return"RunnableBinding"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"bound",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"config",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"kwargs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"configFactories",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.bound=e.bound,this.kwargs=e.kwargs,this.config=e.config,this.configFactories=e.configFactories}getName(e){return this.bound.getName(e)}async _mergeConfig(...e){const t=Gt(this.config,...e);return Gt(t,...this.configFactories?await Promise.all(this.configFactories.map(async n=>await n(t))):[])}bind(e){return new this.constructor({bound:this.bound,kwargs:{...this.kwargs,...e},config:this.config})}withConfig(e){return new this.constructor({bound:this.bound,kwargs:this.kwargs,config:{...this.config,...e}})}withRetry(e){return new wn({bound:this.bound,kwargs:this.kwargs,config:this.config,maxAttemptNumber:e?.stopAfterAttempt,...e})}async invoke(e,t){return this.bound.invoke(e,await this._mergeConfig(_(t),this.kwargs))}async batch(e,t,n){const a=Array.isArray(t)?await Promise.all(t.map(async s=>this._mergeConfig(_(s),this.kwargs))):await this._mergeConfig(_(t),this.kwargs);return this.bound.batch(e,a,n)}_concatOutputChunks(e,t){return this.bound._concatOutputChunks(e,t)}async*_streamIterator(e,t){yield*this.bound._streamIterator(e,await this._mergeConfig(_(t),this.kwargs))}async stream(e,t){return this.bound.stream(e,await this._mergeConfig(_(t),this.kwargs))}async*transform(e,t){yield*this.bound.transform(e,await this._mergeConfig(_(t),this.kwargs))}streamEvents(e,t,n){const a=this,s=async function*(){yield*a.bound.streamEvents(e,{...await a._mergeConfig(_(t),a.kwargs),version:t.version},n)};return N.fromAsyncGenerator(s())}static isRunnableBinding(e){return e.bound&&P.isRunnable(e.bound)}withListeners({onStart:e,onEnd:t,onError:n}){return new ee({bound:this.bound,kwargs:this.kwargs,config:this.config,configFactories:[a=>({callbacks:[new bn({config:a,onStart:e,onEnd:t,onError:n})]})]})}}class Be extends P{static lc_name(){return"RunnableEach"}constructor(e){super(e),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"bound",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.bound=e.bound}bind(e){return new Be({bound:this.bound.bind(e)})}async invoke(e,t){return this._callWithConfig(this._invoke.bind(this),e,t)}async _invoke(e,t,n){return this.bound.batch(e,I(t,{callbacks:n?.getChild()}))}withListeners({onStart:e,onEnd:t,onError:n}){return new Be({bound:this.bound.withListeners({onStart:e,onEnd:t,onError:n})})}}class wn extends ee{static lc_name(){return"RunnableRetry"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"maxAttemptNumber",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(this,"onFailedAttempt",{enumerable:!0,configurable:!0,writable:!0,value:()=>{}}),this.maxAttemptNumber=e.maxAttemptNumber??this.maxAttemptNumber,this.onFailedAttempt=e.onFailedAttempt??this.onFailedAttempt}_patchConfigForRetry(e,t,n){const a=e>1?`retry:attempt:${e}`:void 0;return I(t,{callbacks:n?.getChild(a)})}async _invoke(e,t,n){return rt(a=>super.invoke(e,this._patchConfigForRetry(a,t,n)),{onFailedAttempt:a=>this.onFailedAttempt(a,e),retries:Math.max(this.maxAttemptNumber-1,0),randomize:!0})}async invoke(e,t){return this._callWithConfig(this._invoke.bind(this),e,t)}async _batch(e,t,n,a){const s={};try{await rt(async i=>{const o=e.map((d,h)=>h).filter(d=>s[d.toString()]===void 0||s[d.toString()]instanceof Error),u=o.map(d=>e[d]),l=o.map(d=>this._patchConfigForRetry(i,t?.[d],n?.[d])),c=await super.batch(u,l,{...a,returnExceptions:!0});let f;for(let d=0;d<c.length;d+=1){const h=c[d],p=o[d];h instanceof Error&&f===void 0&&(f=h,f.input=u[d]),s[p.toString()]=h}if(f)throw f;return c},{onFailedAttempt:i=>this.onFailedAttempt(i,i.input),retries:Math.max(this.maxAttemptNumber-1,0),randomize:!0})}catch(i){if(a?.returnExceptions!==!0)throw i}return Object.keys(s).sort((i,o)=>parseInt(i,10)-parseInt(o,10)).map(i=>s[parseInt(i,10)])}async batch(e,t,n){return this._batchWithConfig(this._batch.bind(this),e,t,n)}}class G extends P{static lc_name(){return"RunnableSequence"}constructor(e){super(e),Object.defineProperty(this,"first",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"middle",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"last",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"omitSequenceTags",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),this.first=e.first,this.middle=e.middle??this.middle,this.last=e.last,this.name=e.name,this.omitSequenceTags=e.omitSequenceTags??this.omitSequenceTags}get steps(){return[this.first,...this.middle,this.last]}async invoke(e,t){const n=_(t),s=await(await F(n))?.handleChainStart(this.toJSON(),C(e,"input"),n.runId,void 0,void 0,void 0,n?.runName);delete n.runId;let i=e,o;try{const u=[this.first,...this.middle];for(let l=0;l<u.length;l+=1){const f=u[l].invoke(i,I(n,{callbacks:s?.getChild(this.omitSequenceTags?void 0:`seq:step:${l+1}`)}));i=await Z(f,t?.signal)}if(t?.signal?.aborted)throw new Error("Aborted");o=await this.last.invoke(i,I(n,{callbacks:s?.getChild(this.omitSequenceTags?void 0:`seq:step:${this.steps.length}`)}))}catch(u){throw await s?.handleChainError(u),u}return await s?.handleChainEnd(C(o,"output")),o}async batch(e,t,n){const a=this._getOptionsList(t??{},e.length),s=await Promise.all(a.map(F)),i=await Promise.all(s.map(async(u,l)=>{const c=await u?.handleChainStart(this.toJSON(),C(e[l],"input"),a[l].runId,void 0,void 0,void 0,a[l].runName);return delete a[l].runId,c}));let o=e;try{for(let u=0;u<this.steps.length;u+=1){const c=this.steps[u].batch(o,i.map((f,d)=>{const h=f?.getChild(this.omitSequenceTags?void 0:`seq:step:${u+1}`);return I(a[d],{callbacks:h})}),n);o=await Z(c,a[0]?.signal)}}catch(u){throw await Promise.all(i.map(l=>l?.handleChainError(u))),u}return await Promise.all(i.map(u=>u?.handleChainEnd(C(o,"output")))),o}_concatOutputChunks(e,t){return this.last._concatOutputChunks(e,t)}async*_streamIterator(e,t){const n=await F(t),{runId:a,...s}=t??{},i=await n?.handleChainStart(this.toJSON(),C(e,"input"),a,void 0,void 0,void 0,s?.runName),o=[this.first,...this.middle,this.last];let u=!0,l;async function*c(){yield e}try{let f=o[0].transform(c(),I(s,{callbacks:i?.getChild(this.omitSequenceTags?void 0:"seq:step:1")}));for(let d=1;d<o.length;d+=1)f=await o[d].transform(f,I(s,{callbacks:i?.getChild(this.omitSequenceTags?void 0:`seq:step:${d+1}`)}));for await(const d of f)if(t?.signal?.throwIfAborted(),yield d,u)if(l===void 0)l=d;else try{l=this._concatOutputChunks(l,d)}catch{l=void 0,u=!1}}catch(f){throw await i?.handleChainError(f),f}await i?.handleChainEnd(C(l,"output"))}getGraph(e){const t=new Je;let n=null;return this.steps.forEach((a,s)=>{const i=a.getGraph(e);s!==0&&i.trimFirstNode(),s!==this.steps.length-1&&i.trimLastNode(),t.extend(i);const o=i.firstNode();if(!o)throw new Error(`Runnable ${a} has no first node`);n&&t.addEdge(n,o),n=i.lastNode()}),t}pipe(e){return G.isRunnableSequence(e)?new G({first:this.first,middle:this.middle.concat([this.last,e.first,...e.middle]),last:e.last,name:this.name??e.name}):new G({first:this.first,middle:[...this.middle,this.last],last:Q(e),name:this.name})}static isRunnableSequence(e){return Array.isArray(e.middle)&&P.isRunnable(e)}static from([e,...t],n){let a={};return typeof n=="string"?a.name=n:n!==void 0&&(a=n),new G({...a,first:Q(e),middle:t.slice(0,-1).map(Q),last:Q(t[t.length-1])})}}class fe extends P{static lc_name(){return"RunnableMap"}getStepsKeys(){return Object.keys(this.steps)}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"steps",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.steps={};for(const[t,n]of Object.entries(e.steps))this.steps[t]=Q(n)}static from(e){return new fe({steps:e})}async invoke(e,t){const n=_(t),s=await(await F(n))?.handleChainStart(this.toJSON(),{input:e},n.runId,void 0,void 0,void 0,n?.runName);delete n.runId;const i={};try{const o=Object.entries(this.steps).map(async([u,l])=>{i[u]=await l.invoke(e,I(n,{callbacks:s?.getChild(`map:key:${u}`)}))});await Z(Promise.all(o),t?.signal)}catch(o){throw await s?.handleChainError(o),o}return await s?.handleChainEnd(i),i}async*_transform(e,t,n){const a={...this.steps},s=gn(e,Object.keys(a).length),i=new Map(Object.entries(a).map(([o,u],l)=>{const c=u.transform(s[l],I(n,{callbacks:t?.getChild(`map:key:${o}`)}));return[o,c.next().then(f=>({key:o,gen:c,result:f}))]}));for(;i.size;){const o=Promise.race(i.values()),{key:u,result:l,gen:c}=await Z(o,n?.signal);i.delete(u),l.done||(yield{[u]:l.value},i.set(u,c.next().then(f=>({key:u,gen:c,result:f}))))}}transform(e,t){return this._transformStreamWithConfig(e,this._transform.bind(this),t)}async stream(e,t){async function*n(){yield e}const a=_(t),s=new de({generator:this.transform(n(),a),config:a});return await s.setup,N.fromAsyncGenerator(s)}}class Pt extends P{constructor(e){if(super(e),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"func",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),!bt(e.func))throw new Error("RunnableTraceable requires a function that is wrapped in traceable higher-order function");this.func=e.func}async invoke(e,t){const[n]=this._getOptionsList(t??{},1),a=await F(n),s=this.func(I(n,{callbacks:a}),e);return Z(s,n?.signal)}async*_streamIterator(e,t){const[n]=this._getOptionsList(t??{},1),a=await this.invoke(e,t);if(ht(a)){for await(const s of a)n?.signal?.throwIfAborted(),yield s;return}if(sa(a)){for(;;){n?.signal?.throwIfAborted();const s=a.next();if(s.done)break;yield s.value}return}yield a}static from(e){return new Pt({func:e})}}function oa(r){if(bt(r))throw new Error("RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.")}class xe extends P{static lc_name(){return"RunnableLambda"}constructor(e){if(bt(e.func))return Pt.from(e.func);super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"func",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),oa(e.func),this.func=e.func}static from(e){return new xe({func:e})}async _invoke(e,t,n){return new Promise((a,s)=>{const i=I(t,{callbacks:n?.getChild(),recursionLimit:(t?.recursionLimit??Xe)-1});q.runWithConfig(oe(i),async()=>{try{let o=await this.func(e,{...i});if(o&&P.isRunnable(o)){if(t?.recursionLimit===0)throw new Error("Recursion limit reached.");o=await o.invoke(e,{...i,recursionLimit:(i.recursionLimit??Xe)-1})}else if(ht(o)){let u;for await(const l of pt(i,o))if(t?.signal?.throwIfAborted(),u===void 0)u=l;else try{u=this._concatOutputChunks(u,l)}catch{u=l}o=u}else if(Yt(o)){let u;for(const l of Qt(i,o))if(t?.signal?.throwIfAborted(),u===void 0)u=l;else try{u=this._concatOutputChunks(u,l)}catch{u=l}o=u}a(o)}catch(o){s(o)}})})}async invoke(e,t){return this._callWithConfig(this._invoke.bind(this),e,t)}async*_transform(e,t,n){let a;for await(const o of e)if(a===void 0)a=o;else try{a=this._concatOutputChunks(a,o)}catch{a=o}const s=I(n,{callbacks:t?.getChild(),recursionLimit:(n?.recursionLimit??Xe)-1}),i=await new Promise((o,u)=>{q.runWithConfig(oe(s),async()=>{try{const l=await this.func(a,{...s,config:s});o(l)}catch(l){u(l)}})});if(i&&P.isRunnable(i)){if(n?.recursionLimit===0)throw new Error("Recursion limit reached.");const o=await i.stream(a,s);for await(const u of o)yield u}else if(ht(i))for await(const o of pt(s,i))n?.signal?.throwIfAborted(),yield o;else if(Yt(i))for(const o of Qt(s,i))n?.signal?.throwIfAborted(),yield o;else yield i}transform(e,t){return this._transformStreamWithConfig(e,this._transform.bind(this),t)}async stream(e,t){async function*n(){yield e}const a=_(t),s=new de({generator:this.transform(n(),a),config:a});return await s.setup,N.fromAsyncGenerator(s)}}class ua extends P{static lc_name(){return"RunnableWithFallbacks"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"runnable",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"fallbacks",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.runnable=e.runnable,this.fallbacks=e.fallbacks}*runnables(){yield this.runnable;for(const e of this.fallbacks)yield e}async invoke(e,t){const n=_(t),a=await F(n),{runId:s,...i}=n,o=await a?.handleChainStart(this.toJSON(),C(e,"input"),s,void 0,void 0,void 0,i?.runName),u=I(i,{callbacks:o?.getChild()});return await q.runWithConfig(u,async()=>{let c;for(const f of this.runnables()){n?.signal?.throwIfAborted();try{const d=await f.invoke(e,u);return await o?.handleChainEnd(C(d,"output")),d}catch(d){c===void 0&&(c=d)}}throw c===void 0?new Error("No error stored at end of fallback."):(await o?.handleChainError(c),c)})}async*_streamIterator(e,t){const n=_(t),a=await F(n),{runId:s,...i}=n,o=await a?.handleChainStart(this.toJSON(),C(e,"input"),s,void 0,void 0,void 0,i?.runName);let u,l;for(const f of this.runnables()){n?.signal?.throwIfAborted();const d=I(i,{callbacks:o?.getChild()});try{const h=await f.stream(e,d);l=pt(d,h);break}catch(h){u===void 0&&(u=h)}}if(l===void 0){const f=u??new Error("No error stored at end of fallback.");throw await o?.handleChainError(f),f}let c;try{for await(const f of l){yield f;try{c=c===void 0?c:this._concatOutputChunks(c,f)}catch{c=void 0}}}catch(f){throw await o?.handleChainError(f),f}await o?.handleChainEnd(C(c,"output"))}async batch(e,t,n){if(n?.returnExceptions)throw new Error("Not implemented.");const a=this._getOptionsList(t??{},e.length),s=await Promise.all(a.map(u=>F(u))),i=await Promise.all(s.map(async(u,l)=>{const c=await u?.handleChainStart(this.toJSON(),C(e[l],"input"),a[l].runId,void 0,void 0,void 0,a[l].runName);return delete a[l].runId,c}));let o;for(const u of this.runnables()){a[0].signal?.throwIfAborted();try{const l=await u.batch(e,i.map((c,f)=>I(a[f],{callbacks:c?.getChild()})),n);return await Promise.all(i.map((c,f)=>c?.handleChainEnd(C(l[f],"output")))),l}catch(l){o===void 0&&(o=l)}}throw o?(await Promise.all(i.map(u=>u?.handleChainError(o))),o):new Error("No error stored at end of fallbacks.")}}function Q(r){if(typeof r=="function")return new xe({func:r});if(P.isRunnable(r))return r;if(!Array.isArray(r)&&typeof r=="object"){const e={};for(const[t,n]of Object.entries(r))e[t]=Q(n);return new fe({steps:e})}else throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`)}class vn extends P{static lc_name(){return"RunnableAssign"}constructor(e){e instanceof fe&&(e={mapper:e}),super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"mapper",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.mapper=e.mapper}async invoke(e,t){const n=await this.mapper.invoke(e,t);return{...e,...n}}async*_transform(e,t,n){const a=this.mapper.getStepsKeys(),[s,i]=gn(e),o=this.mapper.transform(i,I(n,{callbacks:t?.getChild()})),u=o.next();for await(const l of s){if(typeof l!="object"||Array.isArray(l))throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof l}`);const c=Object.fromEntries(Object.entries(l).filter(([f])=>!a.includes(f)));Object.keys(c).length>0&&(yield c)}yield(await u).value;for await(const l of o)yield l}transform(e,t){return this._transformStreamWithConfig(e,this._transform.bind(this),t)}async stream(e,t){async function*n(){yield e}const a=_(t),s=new de({generator:this.transform(n(),a),config:a});return await s.setup,N.fromAsyncGenerator(s)}}class la extends P{static lc_name(){return"RunnablePick"}constructor(e){(typeof e=="string"||Array.isArray(e))&&(e={keys:e}),super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"keys",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.keys=e.keys}async _pick(e){if(typeof this.keys=="string")return e[this.keys];{const t=this.keys.map(n=>[n,e[n]]).filter(n=>n[1]!==void 0);return t.length===0?void 0:Object.fromEntries(t)}}async invoke(e,t){return this._callWithConfig(this._pick.bind(this),e,t)}async*_transform(e){for await(const t of e){const n=await this._pick(t);n!==void 0&&(yield n)}}transform(e,t){return this._transformStreamWithConfig(e,this._transform.bind(this),t)}async stream(e,t){async function*n(){yield e}const a=_(t),s=new de({generator:this.transform(n(),a),config:a});return await s.setup,N.fromAsyncGenerator(s)}}class Xt extends ee{constructor(e){const t=G.from([xe.from(async n=>{let a;if(cn(n))try{a=await Xr(this.schema,n.args)}catch{throw new lr("Received tool input did not match expected schema",JSON.stringify(n.args))}else a=n;return a}).withConfig({runName:`${e.name}:parse_input`}),e.bound]).withConfig({runName:e.name});super({bound:t,config:e.config??{}}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"description",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"schema",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=e.name,this.description=e.description,this.schema=e.schema}static lc_name(){return"RunnableToolLike"}}function ca(r,e){const t=e.name??r.getName(),n=e.description??yn(e.schema);return ea(e.schema)?new Xt({name:t,description:n,schema:Fn({input:Dn()}).transform(a=>a.input),bound:r}):new Xt({name:t,description:n,schema:e.schema,bound:r})}/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */var da=typeof window=="object"?window:{},y="0123456789abcdef".split(""),fa=[-2147483648,8388608,32768,128],$=[24,16,8,0],S=[];function D(r){r?(S[0]=S[16]=S[1]=S[2]=S[3]=S[4]=S[5]=S[6]=S[7]=S[8]=S[9]=S[10]=S[11]=S[12]=S[13]=S[14]=S[15]=0,this.blocks=S):this.blocks=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],this.h0=1732584193,this.h1=4023233417,this.h2=2562383102,this.h3=271733878,this.h4=3285377520,this.block=this.start=this.bytes=this.hBytes=0,this.finalized=this.hashed=!1,this.first=!0}D.prototype.update=function(r){if(!this.finalized){var e=typeof r!="string";e&&r.constructor===da.ArrayBuffer&&(r=new Uint8Array(r));for(var t,n=0,a,s=r.length||0,i=this.blocks;n<s;){if(this.hashed&&(this.hashed=!1,i[0]=this.block,i[16]=i[1]=i[2]=i[3]=i[4]=i[5]=i[6]=i[7]=i[8]=i[9]=i[10]=i[11]=i[12]=i[13]=i[14]=i[15]=0),e)for(a=this.start;n<s&&a<64;++n)i[a>>2]|=r[n]<<$[a++&3];else for(a=this.start;n<s&&a<64;++n)t=r.charCodeAt(n),t<128?i[a>>2]|=t<<$[a++&3]:t<2048?(i[a>>2]|=(192|t>>6)<<$[a++&3],i[a>>2]|=(128|t&63)<<$[a++&3]):t<55296||t>=57344?(i[a>>2]|=(224|t>>12)<<$[a++&3],i[a>>2]|=(128|t>>6&63)<<$[a++&3],i[a>>2]|=(128|t&63)<<$[a++&3]):(t=65536+((t&1023)<<10|r.charCodeAt(++n)&1023),i[a>>2]|=(240|t>>18)<<$[a++&3],i[a>>2]|=(128|t>>12&63)<<$[a++&3],i[a>>2]|=(128|t>>6&63)<<$[a++&3],i[a>>2]|=(128|t&63)<<$[a++&3]);this.lastByteIndex=a,this.bytes+=a-this.start,a>=64?(this.block=i[16],this.start=a-64,this.hash(),this.hashed=!0):this.start=a}return this.bytes>4294967295&&(this.hBytes+=this.bytes/4294967296<<0,this.bytes=this.bytes%4294967296),this}};D.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var r=this.blocks,e=this.lastByteIndex;r[16]=this.block,r[e>>2]|=fa[e&3],this.block=r[16],e>=56&&(this.hashed||this.hash(),r[0]=this.block,r[16]=r[1]=r[2]=r[3]=r[4]=r[5]=r[6]=r[7]=r[8]=r[9]=r[10]=r[11]=r[12]=r[13]=r[14]=r[15]=0),r[14]=this.hBytes<<3|this.bytes>>>29,r[15]=this.bytes<<3,this.hash()}};D.prototype.hash=function(){var r=this.h0,e=this.h1,t=this.h2,n=this.h3,a=this.h4,s,i,o,u=this.blocks;for(i=16;i<80;++i)o=u[i-3]^u[i-8]^u[i-14]^u[i-16],u[i]=o<<1|o>>>31;for(i=0;i<20;i+=5)s=e&t|~e&n,o=r<<5|r>>>27,a=o+s+a+1518500249+u[i]<<0,e=e<<30|e>>>2,s=r&e|~r&t,o=a<<5|a>>>27,n=o+s+n+1518500249+u[i+1]<<0,r=r<<30|r>>>2,s=a&r|~a&e,o=n<<5|n>>>27,t=o+s+t+1518500249+u[i+2]<<0,a=a<<30|a>>>2,s=n&a|~n&r,o=t<<5|t>>>27,e=o+s+e+1518500249+u[i+3]<<0,n=n<<30|n>>>2,s=t&n|~t&a,o=e<<5|e>>>27,r=o+s+r+1518500249+u[i+4]<<0,t=t<<30|t>>>2;for(;i<40;i+=5)s=e^t^n,o=r<<5|r>>>27,a=o+s+a+1859775393+u[i]<<0,e=e<<30|e>>>2,s=r^e^t,o=a<<5|a>>>27,n=o+s+n+1859775393+u[i+1]<<0,r=r<<30|r>>>2,s=a^r^e,o=n<<5|n>>>27,t=o+s+t+1859775393+u[i+2]<<0,a=a<<30|a>>>2,s=n^a^r,o=t<<5|t>>>27,e=o+s+e+1859775393+u[i+3]<<0,n=n<<30|n>>>2,s=t^n^a,o=e<<5|e>>>27,r=o+s+r+1859775393+u[i+4]<<0,t=t<<30|t>>>2;for(;i<60;i+=5)s=e&t|e&n|t&n,o=r<<5|r>>>27,a=o+s+a-1894007588+u[i]<<0,e=e<<30|e>>>2,s=r&e|r&t|e&t,o=a<<5|a>>>27,n=o+s+n-1894007588+u[i+1]<<0,r=r<<30|r>>>2,s=a&r|a&e|r&e,o=n<<5|n>>>27,t=o+s+t-1894007588+u[i+2]<<0,a=a<<30|a>>>2,s=n&a|n&r|a&r,o=t<<5|t>>>27,e=o+s+e-1894007588+u[i+3]<<0,n=n<<30|n>>>2,s=t&n|t&a|n&a,o=e<<5|e>>>27,r=o+s+r-1894007588+u[i+4]<<0,t=t<<30|t>>>2;for(;i<80;i+=5)s=e^t^n,o=r<<5|r>>>27,a=o+s+a-899497514+u[i]<<0,e=e<<30|e>>>2,s=r^e^t,o=a<<5|a>>>27,n=o+s+n-899497514+u[i+1]<<0,r=r<<30|r>>>2,s=a^r^e,o=n<<5|n>>>27,t=o+s+t-899497514+u[i+2]<<0,a=a<<30|a>>>2,s=n^a^r,o=t<<5|t>>>27,e=o+s+e-899497514+u[i+3]<<0,n=n<<30|n>>>2,s=t^n^a,o=e<<5|e>>>27,r=o+s+r-899497514+u[i+4]<<0,t=t<<30|t>>>2;this.h0=this.h0+r<<0,this.h1=this.h1+e<<0,this.h2=this.h2+t<<0,this.h3=this.h3+n<<0,this.h4=this.h4+a<<0};D.prototype.hex=function(){this.finalize();var r=this.h0,e=this.h1,t=this.h2,n=this.h3,a=this.h4;return y[r>>28&15]+y[r>>24&15]+y[r>>20&15]+y[r>>16&15]+y[r>>12&15]+y[r>>8&15]+y[r>>4&15]+y[r&15]+y[e>>28&15]+y[e>>24&15]+y[e>>20&15]+y[e>>16&15]+y[e>>12&15]+y[e>>8&15]+y[e>>4&15]+y[e&15]+y[t>>28&15]+y[t>>24&15]+y[t>>20&15]+y[t>>16&15]+y[t>>12&15]+y[t>>8&15]+y[t>>4&15]+y[t&15]+y[n>>28&15]+y[n>>24&15]+y[n>>20&15]+y[n>>16&15]+y[n>>12&15]+y[n>>8&15]+y[n>>4&15]+y[n&15]+y[a>>28&15]+y[a>>24&15]+y[a>>20&15]+y[a>>16&15]+y[a>>12&15]+y[a>>8&15]+y[a>>4&15]+y[a&15]};D.prototype.toString=D.prototype.hex;D.prototype.digest=function(){this.finalize();var r=this.h0,e=this.h1,t=this.h2,n=this.h3,a=this.h4;return[r>>24&255,r>>16&255,r>>8&255,r&255,e>>24&255,e>>16&255,e>>8&255,e&255,t>>24&255,t>>16&255,t>>8&255,t&255,n>>24&255,n>>16&255,n>>8&255,n&255,a>>24&255,a>>16&255,a>>8&255,a&255]};D.prototype.array=D.prototype.digest;D.prototype.arrayBuffer=function(){this.finalize();var r=new ArrayBuffer(20),e=new DataView(r);return e.setUint32(0,this.h0),e.setUint32(4,this.h1),e.setUint32(8,this.h2),e.setUint32(12,this.h3),e.setUint32(16,this.h4),r};let en=!1;const ha=r=>(en||(console.warn(["The default method for hashing keys is insecure and will be replaced in a future version,","but hasn't been replaced yet as to not break existing caches. It's recommended that you use","a more secure hashing algorithm to avoid cache poisoning.","","See this page for more information:","|","> https://js.langchain.com/docs/troubleshooting/warnings/insecure-cache-algorithm"].join(`
`)),en=!0),new D(!0).update(r).hex()),pa=(...r)=>ha(r.join("_"));class ma{constructor(){Object.defineProperty(this,"keyEncoder",{enumerable:!0,configurable:!0,writable:!0,value:pa})}makeDefaultKeyEncoder(e){this.keyEncoder=e}}const ga=new Map;class xt extends ma{constructor(e){super(),Object.defineProperty(this,"cache",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cache=e??new Map}lookup(e,t){return Promise.resolve(this.cache.get(this.keyEncoder(e,t))??null)}async update(e,t,n){this.cache.set(this.keyEncoder(e,t),n)}static global(){return new xt(ga)}}class On extends te{}class ba extends On{static lc_name(){return"StringPromptValue"}constructor(e){super({value:e}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","prompt_values"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"value",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.value=e}toString(){return this.value}toChatMessages(){return[new ze(this.value)]}}class ya extends On{static lc_name(){return"ChatPromptValue"}constructor(e){Array.isArray(e)&&(e={messages:e}),super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","prompt_values"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"messages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.messages=e.messages}toString(){return dn(this.messages)}toChatMessages(){return this.messages}}const Ae={},_a=new Et({});async function wa(r){return r in Ae||(Ae[r]=_a.fetch(`https://tiktoken.pages.dev/js/${r}.json`).then(e=>e.json()).then(e=>new Hn(e)).catch(e=>{throw delete Ae[r],e})),await Ae[r]}async function va(r){return wa(Bn(r))}const Oa=r=>r.startsWith("gpt-3.5-turbo-16k")?"gpt-3.5-turbo-16k":r.startsWith("gpt-3.5-turbo-")?"gpt-3.5-turbo":r.startsWith("gpt-4-32k")?"gpt-4-32k":r.startsWith("gpt-4-")?"gpt-4":r.startsWith("gpt-4o")?"gpt-4o":r;function kn(r){return typeof r!="object"||!r?!1:!!("type"in r&&r.type==="function"&&"function"in r&&typeof r.function=="object"&&r.function&&"name"in r.function&&"parameters"in r.function)}const ka=()=>!1;class Ta extends P{get lc_attributes(){return{callbacks:void 0,verbose:void 0}}constructor(e){super(e),Object.defineProperty(this,"verbose",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"callbacks",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tags",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.verbose=e.verbose??ka(),this.callbacks=e.callbacks,this.tags=e.tags??[],this.metadata=e.metadata??{}}}class Ea extends Ta{get callKeys(){return["stop","timeout","signal","tags","metadata","callbacks"]}constructor({callbacks:e,callbackManager:t,...n}){const{cache:a,...s}=n;super({callbacks:e??t,...s}),Object.defineProperty(this,"caller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cache",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_encoding",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),typeof a=="object"?this.cache=a:a?this.cache=xt.global():this.cache=void 0,this.caller=new Et(n??{})}async getNumTokens(e){let t;typeof e=="string"?t=e:t=e.map(a=>typeof a=="string"?a:a.type==="text"&&"text"in a?a.text:"").join("");let n=Math.ceil(t.length/4);if(!this._encoding)try{this._encoding=await va("modelName"in this?Oa(this.modelName):"gpt2")}catch(a){console.warn("Failed to calculate number of tokens, falling back to approximate count",a)}if(this._encoding)try{n=this._encoding.encode(t).length}catch(a){console.warn("Failed to calculate number of tokens, falling back to approximate count",a)}return n}static _convertInputToPromptValue(e){return typeof e=="string"?new ba(e):Array.isArray(e)?new ya(e.map(pe)):e}_identifyingParams(){return{}}_getSerializedCacheKeyParametersForCall({config:e,...t}){const n={...this._identifyingParams(),...t,_type:this._llmType(),_model:this._modelType()};return Object.entries(n).filter(([i,o])=>o!==void 0).map(([i,o])=>`${i}:${JSON.stringify(o)}`).sort().join(",")}serialize(){return{...this._identifyingParams(),_type:this._llmType(),_model:this._modelType()}}static async deserialize(e){throw new Error("Use .toJSON() instead")}}class He extends P{static lc_name(){return"RunnablePassthrough"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","runnables"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"func",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),e&&(this.func=e.func)}async invoke(e,t){const n=_(t);return this.func&&await this.func(e,n),this._callWithConfig(a=>Promise.resolve(a),e,n)}async*transform(e,t){const n=_(t);let a,s=!0;for await(const i of this._transformStreamWithConfig(e,o=>o,n))if(yield i,s)if(a===void 0)a=i;else try{a=We(a,i)}catch{a=void 0,s=!1}this.func&&a!==void 0&&await this.func(a,n)}static assign(e){return new vn(new fe({steps:e}))}}function tt(r){const e=[];for(const t of r){let n=t;if(Array.isArray(t.content))for(let a=0;a<t.content.length;a++){const s=t.content[a];(Xn(s)||er(s))&&n===t&&(n=new t.constructor({...n,content:[...t.content.slice(0,a),tr(s),...t.content.slice(a+1)]}))}e.push(n)}return e}class V extends Ea{constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","chat_models",this._llmType()]}),Object.defineProperty(this,"disableStreaming",{enumerable:!0,configurable:!0,writable:!0,value:!1})}_separateRunnableConfigFromCallOptionsCompat(e){const[t,n]=super._separateRunnableConfigFromCallOptions(e);return n.signal=t.signal,[t,n]}async invoke(e,t){const n=V._convertInputToPromptValue(e);return(await this.generatePrompt([n],t,t?.callbacks)).generations[0][0].message}async*_streamResponseChunks(e,t,n){throw new Error("Not implemented.")}async*_streamIterator(e,t){if(this._streamResponseChunks===V.prototype._streamResponseChunks||this.disableStreaming)yield this.invoke(e,t);else{const a=V._convertInputToPromptValue(e).toChatMessages(),[s,i]=this._separateRunnableConfigFromCallOptionsCompat(t),o={...s.metadata,...this.getLsParams(i)},u=await j.configure(s.callbacks,this.callbacks,s.tags,this.tags,o,this.metadata,{verbose:this.verbose}),l={options:i,invocation_params:this?.invocationParams(i),batch_size:1},c=await u?.handleChatModelStart(this.toJSON(),[tt(a)],s.runId,void 0,l,void 0,void 0,s.runName);let f,d;try{for await(const h of this._streamResponseChunks(a,i,c?.[0])){if(h.message.id==null){const p=c?.at(0)?.runId;p!=null&&h.message._updateId(`run-${p}`)}h.message.response_metadata={...h.generationInfo,...h.message.response_metadata},yield h.message,f?f=f.concat(h):f=h,Lt(h.message)&&h.message.usage_metadata!==void 0&&(d={tokenUsage:{promptTokens:h.message.usage_metadata.input_tokens,completionTokens:h.message.usage_metadata.output_tokens,totalTokens:h.message.usage_metadata.total_tokens}})}}catch(h){throw await Promise.all((c??[]).map(p=>p?.handleLLMError(h))),h}await Promise.all((c??[]).map(h=>h?.handleLLMEnd({generations:[[f]],llmOutput:d})))}}getLsParams(e){const t=this.getName().startsWith("Chat")?this.getName().replace("Chat",""):this.getName();return{ls_model_type:"chat",ls_stop:e.stop,ls_provider:t}}async _generateUncached(e,t,n,a){const s=e.map(f=>f.map(pe));let i;if(a!==void 0&&a.length===s.length)i=a;else{const f={...n.metadata,...this.getLsParams(t)},d=await j.configure(n.callbacks,this.callbacks,n.tags,this.tags,f,this.metadata,{verbose:this.verbose}),h={options:t,invocation_params:this?.invocationParams(t),batch_size:1};i=await d?.handleChatModelStart(this.toJSON(),s.map(tt),n.runId,void 0,h,void 0,void 0,n.runName)}const o=[],u=[];if(!!i?.[0].handlers.find(wr)&&!this.disableStreaming&&s.length===1&&this._streamResponseChunks!==V.prototype._streamResponseChunks)try{const f=await this._streamResponseChunks(s[0],t,i?.[0]);let d,h;for await(const p of f){if(p.message.id==null){const m=i?.at(0)?.runId;m!=null&&p.message._updateId(`run-${m}`)}d===void 0?d=p:d=We(d,p),Lt(p.message)&&p.message.usage_metadata!==void 0&&(h={tokenUsage:{promptTokens:p.message.usage_metadata.input_tokens,completionTokens:p.message.usage_metadata.output_tokens,totalTokens:p.message.usage_metadata.total_tokens}})}if(d===void 0)throw new Error("Received empty response from chat model call.");o.push([d]),await i?.[0].handleLLMEnd({generations:o,llmOutput:h})}catch(f){throw await i?.[0].handleLLMError(f),f}else{const f=await Promise.allSettled(s.map((d,h)=>this._generate(d,{...t,promptIndex:h},i?.[h])));await Promise.all(f.map(async(d,h)=>{if(d.status==="fulfilled"){const p=d.value;for(const m of p.generations){if(m.message.id==null){const g=i?.at(0)?.runId;g!=null&&m.message._updateId(`run-${g}`)}m.message.response_metadata={...m.generationInfo,...m.message.response_metadata}}return p.generations.length===1&&(p.generations[0].message.response_metadata={...p.llmOutput,...p.generations[0].message.response_metadata}),o[h]=p.generations,u[h]=p.llmOutput,i?.[h]?.handleLLMEnd({generations:[p.generations],llmOutput:p.llmOutput})}else return await i?.[h]?.handleLLMError(d.reason),Promise.reject(d.reason)}))}const c={generations:o,llmOutput:u.length?this._combineLLMOutput?.(...u):void 0};return Object.defineProperty(c,Vt,{value:i?{runIds:i?.map(f=>f.runId)}:void 0,configurable:!0}),c}async _generateCached({messages:e,cache:t,llmStringKey:n,parsedOptions:a,handledOptions:s}){const i=e.map(g=>g.map(pe)),o={...s.metadata,...this.getLsParams(a)},u=await j.configure(s.callbacks,this.callbacks,s.tags,this.tags,o,this.metadata,{verbose:this.verbose}),l={options:a,invocation_params:this?.invocationParams(a),batch_size:1},c=await u?.handleChatModelStart(this.toJSON(),i.map(tt),s.runId,void 0,l,void 0,void 0,s.runName),f=[],h=(await Promise.allSettled(i.map(async(g,b)=>{const w=V._convertInputToPromptValue(g).toString(),v=await t.lookup(w,n);return v==null&&f.push(b),v}))).map((g,b)=>({result:g,runManager:c?.[b]})).filter(({result:g})=>g.status==="fulfilled"&&g.value!=null||g.status==="rejected"),p=[];await Promise.all(h.map(async({result:g,runManager:b},w)=>{if(g.status==="fulfilled"){const v=g.value;return p[w]=v.map(k=>("message"in k&&Ee(k.message)&&wt(k.message)&&(k.message.usage_metadata={input_tokens:0,output_tokens:0,total_tokens:0}),k.generationInfo={...k.generationInfo,tokenUsage:{}},k)),v.length&&await b?.handleLLMNewToken(v[0].text),b?.handleLLMEnd({generations:[v]},void 0,void 0,void 0,{cached:!0})}else return await b?.handleLLMError(g.reason,void 0,void 0,void 0,{cached:!0}),Promise.reject(g.reason)}));const m={generations:p,missingPromptIndices:f,startedRunManagers:c};return Object.defineProperty(m,Vt,{value:c?{runIds:c?.map(g=>g.runId)}:void 0,configurable:!0}),m}async generate(e,t,n){let a;Array.isArray(t)?a={stop:t}:a=t;const s=e.map(p=>p.map(pe)),[i,o]=this._separateRunnableConfigFromCallOptionsCompat(a);if(i.callbacks=i.callbacks??n,!this.cache)return this._generateUncached(s,o,i);const{cache:u}=this,l=this._getSerializedCacheKeyParametersForCall(o),{generations:c,missingPromptIndices:f,startedRunManagers:d}=await this._generateCached({messages:s,cache:u,llmStringKey:l,parsedOptions:o,handledOptions:i});let h={};if(f.length>0){const p=await this._generateUncached(f.map(m=>s[m]),o,i,d!==void 0?f.map(m=>d?.[m]):void 0);await Promise.all(p.generations.map(async(m,g)=>{const b=f[g];c[b]=m;const w=V._convertInputToPromptValue(s[b]).toString();return u.update(w,l,m)})),h=p.llmOutput??{}}return{generations:c,llmOutput:h}}invocationParams(e){return{}}_modelType(){return"base_chat_model"}serialize(){return{...this.invocationParams(),_type:this._llmType(),_model:this._modelType()}}async generatePrompt(e,t,n){const a=e.map(s=>s.toChatMessages());return this.generate(a,t,n)}async call(e,t,n){return(await this.generate([e.map(pe)],t,n)).generations[0][0].message}async callPrompt(e,t,n){const a=e.toChatMessages();return this.call(a,t,n)}async predictMessages(e,t,n){return this.call(e,t,n)}async predict(e,t,n){const a=new ze(e),s=await this.call([a],t,n);if(typeof s.content!="string")throw new Error("Cannot use predict when output is not a string.");return s.content}withStructuredOutput(e,t){if(typeof this.bindTools!="function")throw new Error('Chat model must implement ".bindTools()" to use withStructuredOutput.');if(t?.strict)throw new Error('"strict" mode is not supported for this model by default.');const n=e,a=t?.name,s=yn(n)??"A function available to call.",i=t?.method,o=t?.includeRaw;if(i==="jsonMode")throw new Error('Base withStructuredOutput implementation only supports "functionCalling" as a method.');let u=a??"extract",l;Pe(n)?l=[{type:"function",function:{name:u,description:s,parameters:Ct(n)}}]:("name"in n&&(u=n.name),l=[{type:"function",function:{name:u,description:s,parameters:n}}]);const c=this.bindTools(l),f=xe.from(m=>{if(!m.tool_calls||m.tool_calls.length===0)throw new Error("No tool calls found in the response.");const g=m.tool_calls.find(b=>b.name===u);if(!g)throw new Error(`No tool call found with name ${u}.`);return g.args});if(!o)return c.pipe(f).withConfig({runName:"StructuredOutput"});const d=He.assign({parsed:(m,g)=>f.invoke(m.raw,g)}),h=He.assign({parsed:()=>null}),p=d.withFallbacks({fallbacks:[h]});return G.from([{raw:c},p]).withConfig({runName:"StructuredOutputRunnable"})}}class Tn extends P{parseResultWithPrompt(e,t,n){return this.parseResult(e,n)}_baseMessageToString(e){return typeof e.content=="string"?e.content:this._baseMessageContentToString(e.content)}_baseMessageContentToString(e){return JSON.stringify(e)}async invoke(e,t){return typeof e=="string"?this._callWithConfig(async(n,a)=>this.parseResult([{text:n}],a?.callbacks),e,{...t,runType:"parser"}):this._callWithConfig(async(n,a)=>this.parseResult([{message:n,text:this._baseMessageToString(n)}],a?.callbacks),e,{...t,runType:"parser"})}}class Sa extends Tn{parseResult(e,t){return this.parse(e[0].text,t)}async parseWithPrompt(e,t,n){return this.parse(e,n)}_type(){throw new Error("_type not implemented")}}class Ca extends Error{constructor(e,t,n,a=!1){if(super(e),Object.defineProperty(this,"llmOutput",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"observation",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"sendToLLM",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.llmOutput=t,this.observation=n,this.sendToLLM=a,a&&(n===void 0||t===void 0))throw new Error("Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true");ln(this,"OUTPUT_PARSING_FAILURE")}}class Pa extends Sa{async*_transform(e){for await(const t of e)typeof t=="string"?yield this.parseResult([{text:t}]):yield this.parseResult([{message:t,text:this._baseMessageToString(t)}])}async*transform(e,t){yield*this._transformStreamWithConfig(e,this._transform.bind(this),{...t,runType:"parser"})}}class xa extends Pa{constructor(e){super(e),Object.defineProperty(this,"diff",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.diff=e?.diff??this.diff}async*_transform(e){let t,n;for await(const a of e){if(typeof a!="string"&&typeof a.content!="string")throw new Error("Cannot handle non-string output.");let s;if(ir(a)){if(typeof a.content!="string")throw new Error("Cannot handle non-string message output.");s=new Oe({message:a,text:a.content})}else if(Ee(a)){if(typeof a.content!="string")throw new Error("Cannot handle non-string message output.");s=new Oe({message:fr(a),text:a.content})}else s=new ue({text:a});n===void 0?n=s:n=n.concat(s);const i=await this.parsePartialResult([n]);i!=null&&!Un(i,t)&&(this.diff?yield this._diff(t,i):yield i,t=i)}}getFormatInstructions(){return""}}class Ia extends xa{constructor(){super(...arguments),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain_core","output_parsers"]}),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0})}static lc_name(){return"JsonOutputParser"}_concatOutputChunks(e,t){return this.diff?super._concatOutputChunks(e,t):t}_diff(e,t){if(t)return e?yr(e,t):[{op:"replace",path:"",value:t}]}async parsePartialResult(e){return Nt(e[0].text)}async parse(e){return Nt(e,JSON.parse)}getFormatInstructions(){return""}}function ne(r){if(typeof r=="object"&&r!==null){const e={...r};"additionalProperties"in e&&delete e.additionalProperties,"$schema"in e&&delete e.$schema,"strict"in e&&delete e.strict;for(const t in e)t in e&&(Array.isArray(e[t])?e[t]=e[t].map(ne):typeof e[t]=="object"&&e[t]!==null&&(e[t]=ne(e[t])));return e}return r}function mt(r){const e=ne(Pe(r)?Ct(r):r),{$schema:t,...n}=e;return n}function Ra(r){const e=ne(r),{$schema:t,...n}=e;return n}function Aa(r){return r!==void 0&&Array.isArray(r.lc_namespace)}function ja(r){return r!==void 0&&P.isRunnable(r)&&"lc_name"in r.constructor&&typeof r.constructor.lc_name=="function"&&r.constructor.lc_name()==="RunnableToolLike"}function Na(r){return!!r&&typeof r=="object"&&"name"in r&&"schema"in r&&(Pe(r.schema)||r.schema!=null&&typeof r.schema=="object"&&"type"in r.schema&&typeof r.schema.type=="string"&&["null","boolean","object","array","number","string"].includes(r.schema.type))}function En(r){return Na(r)||ja(r)||Aa(r)}const x=[];for(let r=0;r<256;++r)x.push((r+256).toString(16).slice(1));function Ma(r,e=0){return(x[r[e+0]]+x[r[e+1]]+x[r[e+2]]+x[r[e+3]]+"-"+x[r[e+4]]+x[r[e+5]]+"-"+x[r[e+6]]+x[r[e+7]]+"-"+x[r[e+8]]+x[r[e+9]]+"-"+x[r[e+10]]+x[r[e+11]]+x[r[e+12]]+x[r[e+13]]+x[r[e+14]]+x[r[e+15]]).toLowerCase()}let nt;const La=new Uint8Array(16);function $a(){if(!nt){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");nt=crypto.getRandomValues.bind(crypto)}return nt(La)}const Fa=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),tn={randomUUID:Fa};function Sn(r,e,t){if(tn.randomUUID&&!r)return tn.randomUUID();r=r||{};const n=r.random??r.rng?.()??$a();if(n.length<16)throw new Error("Random bytes length must be >= 16");return n[6]=n[6]&15|64,n[8]=n[8]&63|128,Ma(n)}function Da(r){const e=r._getType();return Ue.isInstance(r)?r.role:e==="tool"?e:r.name??e}function Ba(r){switch(r){case"supervisor":case"ai":case"model":return"model";case"system":return"system";case"human":return"user";case"tool":case"function":return"function";default:throw new Error(`Unknown / unsupported author: ${r}`)}}function Ha(r){if("mimeType"in r&&"data"in r)return{inlineData:{mimeType:r.mimeType,data:r.data}};if("mimeType"in r&&"fileUri"in r)return{fileData:{mimeType:r.mimeType,fileUri:r.fileUri}};throw new Error("Invalid media content")}function Ua(r,e){return e.map(t=>wt(t)?t.tool_calls??[]:[]).flat().find(t=>t.id===r.tool_call_id)?.name}function za(r){return{providerName:"Google Gemini",fromStandardTextBlock(t){return{text:t.text}},fromStandardImageBlock(t){if(!r)throw new Error("This model does not support images");if(t.source_type==="url"){const n=qe({dataUrl:t.url});return n?{inlineData:{mimeType:n.mime_type,data:n.data}}:{fileData:{mimeType:t.mime_type??"",fileUri:t.url}}}if(t.source_type==="base64")return{inlineData:{mimeType:t.mime_type??"",data:t.data}};throw new Error(`Unsupported source type: ${t.source_type}`)},fromStandardAudioBlock(t){if(!r)throw new Error("This model does not support audio");if(t.source_type==="url"){const n=qe({dataUrl:t.url});return n?{inlineData:{mimeType:n.mime_type,data:n.data}}:{fileData:{mimeType:t.mime_type??"",fileUri:t.url}}}if(t.source_type==="base64")return{inlineData:{mimeType:t.mime_type??"",data:t.data}};throw new Error(`Unsupported source type: ${t.source_type}`)},fromStandardFileBlock(t){if(!r)throw new Error("This model does not support files");if(t.source_type==="text")return{text:t.text};if(t.source_type==="url"){const n=qe({dataUrl:t.url});return n?{inlineData:{mimeType:n.mime_type,data:n.data}}:{fileData:{mimeType:t.mime_type??"",fileUri:t.url}}}if(t.source_type==="base64")return{inlineData:{mimeType:t.mime_type??"",data:t.data}};throw new Error(`Unsupported source type: ${t.source_type}`)}}}function nn(r,e){if(se(r))return nr(r,za(e));if(r.type==="text")return{text:r.text};if(r.type==="executableCode")return{executableCode:r.executableCode};if(r.type==="codeExecutionResult")return{codeExecutionResult:r.codeExecutionResult};if(r.type==="image_url"){if(!e)throw new Error("This model does not support images");let t;if(typeof r.image_url=="string")t=r.image_url;else if(typeof r.image_url=="object"&&"url"in r.image_url)t=r.image_url.url;else throw new Error("Please provide image as base64 encoded data URL");const[n,a]=t.split(",");if(!n.startsWith("data:"))throw new Error("Please provide image as base64 encoded data URL");const[s,i]=n.replace(/^data:/,"").split(";");if(i!=="base64")throw new Error("Please provide image as base64 encoded data URL");return{inlineData:{data:a,mimeType:s}}}else{if(r.type==="media")return Ha(r);if(r.type==="tool_use")return{functionCall:{name:r.name,args:r.input}};if(r.type?.includes("/")&&r.type.split("/").length===2&&"data"in r&&typeof r.data=="string")return{inlineData:{mimeType:r.type,data:r.data}};if("functionCall"in r)return;throw"type"in r?new Error(`Unknown content type ${r.type}`):new Error(`Unknown content ${JSON.stringify(r)}`)}}function Ga(r,e,t){if(ur(r)){const s=r.name??Ua(r,t);if(s===void 0)throw new Error(`Google requires a tool name for each tool call response, and we could not infer a called tool name for ToolMessage "${r.id}" from your passed messages. Please populate a "name" field on that ToolMessage explicitly.`);const i=Array.isArray(r.content)?r.content.map(o=>nn(o,e)).filter(o=>o!==void 0):r.content;return r.status==="error"?[{functionResponse:{name:s,response:{error:{details:i}}}}]:[{functionResponse:{name:s,response:{result:i}}}]}let n=[];const a=[];return typeof r.content=="string"&&r.content&&a.push({text:r.content}),Array.isArray(r.content)&&a.push(...r.content.map(s=>nn(s,e)).filter(s=>s!==void 0)),wt(r)&&r.tool_calls?.length&&(n=r.tool_calls.map(s=>({functionCall:{name:s.name,args:s.args}}))),[...a,...n]}function rn(r,e,t=!1){return r.reduce((n,a,s)=>{if(!Ee(a))throw new Error("Unsupported message input");const i=Da(a);if(i==="system"&&s!==0)throw new Error("System message should be the first one");const o=Ba(i),u=n.content[n.content.length];if(!n.mergeWithPreviousContent&&u&&u.role===o)throw new Error("Google Generative AI requires alternate messages between authors");const l=Ga(a,e,r.slice(0,s));if(n.mergeWithPreviousContent){const d=n.content[n.content.length-1];if(!d)throw new Error("There was a problem parsing your system message. Please try a prompt without one.");return d.parts.push(...l),{mergeWithPreviousContent:!1,content:n.content}}let c=o;(c==="function"||c==="system"&&!t)&&(c="user");const f={role:c,parts:l};return{mergeWithPreviousContent:i==="system"&&!t,content:[...n.content,f]}},{content:[],mergeWithPreviousContent:!1}).content}function Wa(r,e){if(!r.candidates||r.candidates.length===0||!r.candidates[0])return{generations:[],llmOutput:{filters:r.promptFeedback}};const t=r.functionCalls(),[n]=r.candidates,{content:a,...s}=n;let i;Array.isArray(a?.parts)&&a.parts.length===1&&a.parts[0].text?i=a.parts[0].text:Array.isArray(a?.parts)&&a.parts.length>0?i=a.parts.map(l=>"text"in l?{type:"text",text:l.text}:"executableCode"in l?{type:"executableCode",executableCode:l.executableCode}:"codeExecutionResult"in l?{type:"codeExecutionResult",codeExecutionResult:l.codeExecutionResult}:l):i=[];let o="";return typeof i=="string"?o=i:Array.isArray(i)&&i.length>0&&(o=i.find(c=>"text"in c)?.text??o),{generations:[{text:o,message:new at({content:i??"",tool_calls:t?.map(l=>({...l,type:"tool_call",id:"id"in l&&typeof l.id=="string"?l.id:Sn()})),additional_kwargs:{...s},usage_metadata:e?.usageMetadata}),generationInfo:s}],llmOutput:{tokenUsage:{promptTokens:e?.usageMetadata?.input_tokens,completionTokens:e?.usageMetadata?.output_tokens,totalTokens:e?.usageMetadata?.total_tokens}}}}function Ja(r,e){if(!r.candidates||r.candidates.length===0)return null;const t=r.functionCalls(),[n]=r.candidates,{content:a,...s}=n;let i;Array.isArray(a?.parts)&&a.parts.every(l=>"text"in l)?i=a.parts.map(l=>l.text).join(""):Array.isArray(a?.parts)?i=a.parts.map(l=>"text"in l?{type:"text",text:l.text}:"executableCode"in l?{type:"executableCode",executableCode:l.executableCode}:"codeExecutionResult"in l?{type:"codeExecutionResult",codeExecutionResult:l.codeExecutionResult}:l):i=[];let o="";i&&typeof i=="string"?o=i:Array.isArray(i)&&(o=i.find(c=>"text"in c)?.text??"");const u=[];return t&&u.push(...t.map(l=>({...l,args:JSON.stringify(l.args),index:e.index,type:"tool_call_chunk",id:"id"in l&&typeof l.id=="string"?l.id:Sn()}))),new Oe({text:o,message:new ce({content:i||"",name:a?a.role:void 0,tool_call_chunks:u,additional_kwargs:{},usage_metadata:e.usageMetadata}),generationInfo:s})}function Ka(r){return r.every(e=>"functionDeclarations"in e&&Array.isArray(e.functionDeclarations))?r:[{functionDeclarations:r.map(e=>{if(En(e)){const t=mt(e.schema);return t.type==="object"&&"properties"in t&&Object.keys(t.properties).length===0?{name:e.name,description:e.description}:{name:e.name,description:e.description,parameters:t}}return kn(e)?{name:e.function.name,description:e.function.description??"A function available to call.",parameters:Ra(e.function.parameters)}:e})}]}class an extends Tn{static lc_name(){return"GoogleGenerativeAIToolsOutputParser"}constructor(e){super(e),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","google_genai","output_parsers"]}),Object.defineProperty(this,"returnId",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"keyName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"returnSingle",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"zodSchema",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.keyName=e.keyName,this.returnSingle=e.returnSingle??this.returnSingle,this.zodSchema=e.zodSchema}async _validateResult(e){if(this.zodSchema===void 0)return e;const t=await Qr(this.zodSchema,e);if(t.success)return t.data;throw new Ca(`Failed to parse. Text: "${JSON.stringify(e,null,2)}". Error: ${JSON.stringify(t.error.issues)}`,JSON.stringify(e,null,2))}async parseResult(e){const t=e.flatMap(s=>{const{message:i}=s;return!("tool_calls"in i)||!Array.isArray(i.tool_calls)?[]:i.tool_calls});if(t[0]===void 0)throw new Error("No parseable tool calls provided to GoogleGenerativeAIToolsOutputParser.");const[n]=t;return await this._validateResult(n.args)}}function sn(r,e){const t=Va(r),n=Za(t,e);return{tools:t,toolConfig:n}}function Va(r){let e=[];const t=[];return r.forEach(a=>{if(En(a)){const[s]=Ka([a]);s.functionDeclarations&&e.push(...s.functionDeclarations)}else if(kn(a)){const{functionDeclarations:s}=qa(a);if(s)e.push(...s);else throw new Error("Failed to convert OpenAI structured tool to GenerativeAI tool")}else t.push(a)}),t.find(a=>"functionDeclarations"in a)?t.map(a=>{if(e?.length>0&&"functionDeclarations"in a){const s={functionDeclarations:[...a.functionDeclarations||[],...e]};return e=[],s}return a}):[...t,...e.length>0?[{functionDeclarations:e}]:[]]}function qa(r){return{functionDeclarations:[{name:r.function.name,description:r.function.description,parameters:ne(r.function.parameters)}]}}function Za(r,e){if(!r.length||!e)return;const{toolChoice:t,allowedFunctionNames:n}=e,a={any:Ie.ANY,auto:Ie.AUTO,none:Ie.NONE};if(t&&["any","auto","none"].includes(t))return{functionCallingConfig:{mode:a[t]??"MODE_UNSPECIFIED",allowedFunctionNames:n}};if(typeof t=="string"||n)return{functionCallingConfig:{mode:Ie.ANY,allowedFunctionNames:[...n??[],...t&&typeof t=="string"?[t]:[]]}}}class ei extends V{static lc_name(){return"ChatGoogleGenerativeAI"}get lc_secrets(){return{apiKey:"GOOGLE_API_KEY"}}get lc_aliases(){return{apiKey:"google_api_key"}}get _isMultimodalModel(){return this.model.includes("vision")||this.model.startsWith("gemini-1.5")||this.model.startsWith("gemini-2")}constructor(e){if(super(e),Object.defineProperty(this,"lc_serializable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"lc_namespace",{enumerable:!0,configurable:!0,writable:!0,value:["langchain","chat_models","google_genai"]}),Object.defineProperty(this,"model",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"temperature",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"maxOutputTokens",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"topP",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"topK",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"stopSequences",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"safetySettings",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"apiKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"streaming",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"json",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"streamUsage",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"convertSystemMessageToHumanContent",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"client",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.model=e.model.replace(/^models\//,""),this.maxOutputTokens=e.maxOutputTokens??this.maxOutputTokens,this.maxOutputTokens&&this.maxOutputTokens<0)throw new Error("`maxOutputTokens` must be a positive integer");if(this.temperature=e.temperature??this.temperature,this.temperature&&(this.temperature<0||this.temperature>2))throw new Error("`temperature` must be in the range of [0.0,2.0]");if(this.topP=e.topP??this.topP,this.topP&&this.topP<0)throw new Error("`topP` must be a positive integer");if(this.topP&&this.topP>1)throw new Error("`topP` must be below 1.");if(this.topK=e.topK??this.topK,this.topK&&this.topK<0)throw new Error("`topK` must be a positive integer");if(this.stopSequences=e.stopSequences??this.stopSequences,this.apiKey=e.apiKey??X("GOOGLE_API_KEY"),!this.apiKey)throw new Error("Please set an API key for Google GenerativeAI in the environment variable GOOGLE_API_KEY or in the `apiKey` field of the ChatGoogleGenerativeAI constructor");if(this.safetySettings=e.safetySettings??this.safetySettings,this.safetySettings&&this.safetySettings.length>0&&new Set(this.safetySettings.map(n=>n.category)).size!==this.safetySettings.length)throw new Error("The categories in `safetySettings` array must be unique");this.streaming=e.streaming??this.streaming,this.json=e.json,this.client=new jt(this.apiKey).getGenerativeModel({model:this.model,safetySettings:this.safetySettings,generationConfig:{stopSequences:this.stopSequences,maxOutputTokens:this.maxOutputTokens,temperature:this.temperature,topP:this.topP,topK:this.topK,...this.json?{responseMimeType:"application/json"}:{}}},{apiVersion:e.apiVersion,baseUrl:e.baseUrl}),this.streamUsage=e.streamUsage??this.streamUsage}useCachedContent(e,t,n){this.apiKey&&(this.client=new jt(this.apiKey).getGenerativeModelFromCachedContent(e,t,n))}get useSystemInstruction(){return typeof this.convertSystemMessageToHumanContent=="boolean"?!this.convertSystemMessageToHumanContent:this.computeUseSystemInstruction}get computeUseSystemInstruction(){return this.model==="gemini-1.0-pro-001"||this.model.startsWith("gemini-pro-vision")||this.model.startsWith("gemini-1.0-pro-vision")?!1:this.model!=="gemini-pro"}getLsParams(e){return{ls_provider:"google_genai",ls_model_name:this.model,ls_model_type:"chat",ls_temperature:this.client.generationConfig.temperature,ls_max_tokens:this.client.generationConfig.maxOutputTokens,ls_stop:e.stop}}_combineLLMOutput(){return[]}_llmType(){return"googlegenerativeai"}bindTools(e,t){return this.withConfig({tools:sn(e)?.tools,...t})}invocationParams(e){const t=e?.tools?.length?sn(e.tools,{toolChoice:e.tool_choice,allowedFunctionNames:e.allowedFunctionNames}):void 0;return e?.responseSchema?(this.client.generationConfig.responseSchema=e.responseSchema,this.client.generationConfig.responseMimeType="application/json"):(this.client.generationConfig.responseSchema=void 0,this.client.generationConfig.responseMimeType=this.json?"application/json":void 0),{...t?.tools?{tools:t.tools}:{},...t?.toolConfig?{toolConfig:t.toolConfig}:{}}}async _generate(e,t,n){const a=rn(e,this._isMultimodalModel,this.useSystemInstruction);let s=a;if(a[0].role==="system"){const[c]=a;this.client.systemInstruction=c,s=a.slice(1)}const i=this.invocationParams(t);if(this.streaming){const c={},f=this._streamResponseChunks(e,t,n),d={};for await(const p of f){const m=p.generationInfo?.completion??0;d[m]===void 0?d[m]=p:d[m]=d[m].concat(p)}return{generations:Object.entries(d).sort(([p],[m])=>parseInt(p,10)-parseInt(m,10)).map(([p,m])=>m),llmOutput:{estimatedTokenUsage:c}}}const o=await this.completionWithRetry({...i,contents:s});let u;if("usageMetadata"in o.response){const c=o.response.usageMetadata;u={input_tokens:c.promptTokenCount??0,output_tokens:c.candidatesTokenCount??0,total_tokens:c.totalTokenCount??0}}const l=Wa(o.response,{usageMetadata:u});return l.generations?.length>0&&await n?.handleLLMNewToken(l.generations[0]?.text??""),l}async*_streamResponseChunks(e,t,n){const a=rn(e,this._isMultimodalModel,this.useSystemInstruction);let s=a;if(a[0].role==="system"){const[f]=a;this.client.systemInstruction=f,s=a.slice(1)}const o={...this.invocationParams(t),contents:s},u=await this.caller.callWithOptions({signal:t?.signal},async()=>{const{stream:f}=await this.client.generateContentStream(o);return f});let l,c=0;for await(const f of u){if("usageMetadata"in f&&this.streamUsage!==!1&&t.streamUsage!==!1){const h=f.usageMetadata;if(!l)l={input_tokens:h.promptTokenCount??0,output_tokens:h.candidatesTokenCount??0,total_tokens:h.totalTokenCount??0};else{const p=(h.candidatesTokenCount??0)-l.output_tokens;l={input_tokens:0,output_tokens:p,total_tokens:p}}}const d=Ja(f,{usageMetadata:l,index:c});c+=1,d&&(yield d,await n?.handleLLMNewToken(d.text??""))}}async completionWithRetry(e,t){return this.caller.callWithOptions({signal:t?.signal},async()=>{try{return await this.client.generateContent(e)}catch(n){throw n.message?.includes("400 Bad Request")&&(n.status=400),n}})}withStructuredOutput(e,t){const n=e,a=t?.name,s=t?.method,i=t?.includeRaw;if(s==="jsonMode")throw new Error('ChatGoogleGenerativeAI only supports "jsonSchema" or "functionCalling" as a method.');let o,u;if(s==="functionCalling"){let d=a??"extract",h;if(Pe(n)){const p=mt(n);h=[{functionDeclarations:[{name:d,description:p.description??"A function available to call.",parameters:p}]}],u=new an({returnSingle:!0,keyName:d,zodSchema:n})}else{let p;typeof n.name=="string"&&typeof n.parameters=="object"&&n.parameters!=null?(p=n,p.parameters=ne(n.parameters),d=n.name):p={name:d,description:n.description??"",parameters:ne(n)},h=[{functionDeclarations:[p]}],u=new an({returnSingle:!0,keyName:d})}o=this.bindTools(h).withConfig({allowedFunctionNames:[d]})}else{const d=mt(n);o=this.withConfig({responseSchema:d}),u=new Ia}if(!i)return o.pipe(u).withConfig({runName:"ChatGoogleGenerativeAIStructuredOutput"});const l=He.assign({parsed:(d,h)=>u.invoke(d.raw,h)}),c=He.assign({parsed:()=>null}),f=l.withFallbacks({fallbacks:[c]});return G.from([{raw:o},f]).withConfig({runName:"StructuredOutputRunnable"})}}export{at as A,ei as C,ze as H,$t as S};
